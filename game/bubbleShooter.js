export class BubbleShooterGame {
  constructor(container) {
    this.container = container;
    this.canvas = container.querySelector('#gameCanvas');
    this.ctx = this.canvas.getContext('2d');
    
    // –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞ —è–∫—ñ—Å—Ç—å –∑–æ–±—Ä–∞–∂–µ–Ω—å –¥–ª—è —á—ñ—Ç–∫–∏—Ö —Å–ø—Ä–∞–π—Ç—ñ–≤
    this.ctx.imageSmoothingEnabled = false; // –í—ñ–¥–∫–ª—é—á–∞—î–º–æ –∑–≥–ª–∞–¥–∂—É–≤–∞–Ω–Ω—è –¥–ª—è —á—ñ—Ç–∫–∏—Ö –ø—ñ–∫—Å–µ–ª–µ–≤–∏—Ö —Å–ø—Ä–∞–π—Ç—ñ–≤
    
    // –ö–µ—à –¥–ª—è –ø–æ–∑–∏—Ü—ñ–π –±—É–ª—å–±–∞—à–æ–∫ (spatial optimization)
    this.activeBubbles = new Map(); // row,col -> {x, y, type}
    this.bubbleQuadTree = new Map(); // spatial partitioning for collision
    
    this.canvas.width = 480; // –ó–±—ñ–ª—å—à—É—î–º–æ –∑ 400 –¥–æ 480 –¥–ª—è –∫—Ä–∞—â–æ—ó —è–∫–æ—Å—Ç—ñ
    this.canvas.height = 720; // –ó–±—ñ–ª—å—à—É—î–º–æ –∑ 600 –¥–æ 720 –¥–ª—è –∫—Ä–∞—â–æ—ó —è–∫–æ—Å—Ç—ñ
    this.playAreaWidth = this.canvas.width;
    this.playAreaHeight = this.canvas.height - 120;
    
    this.bubbleRadius = 22; // –ó–±—ñ–ª—å—à—É—î–º–æ –∑ 18 –¥–æ 22 –¥–ª—è –∫—Ä–∞—â–æ—ó –¥–µ—Ç–∞–ª—ñ–∑–∞—Ü—ñ—ó —Å–ø—Ä–∞–π—Ç—ñ–≤
    this.cols = 12; // –ó–º–µ–Ω—à—É—î–º–æ –∑ 13 –¥–æ 12 –¥–ª—è –±—ñ–ª—å—à–æ–≥–æ –ø—Ä–æ—Å—Ç–æ—Ä—É
    this.rows = 12; // –ó–º–µ–Ω—à—É—î–º–æ –∑ 14 –¥–æ 12 –¥–ª—è –º–µ–Ω—à –ø–µ—Ä–µ–ø–æ–≤–Ω–µ–Ω–æ–≥–æ –ø–æ–ª—è
    this.sidePadding = 60; // –ë—É–ª–æ 25, —Ç–µ–ø–µ—Ä 60px –¥–ª—è –≤—É–∂—á–æ–≥–æ –ø–æ–ª—è
    this.shooterY = this.canvas.height - this.bubbleRadius * 1.5; // –ü–æ–∑–∏—Ü—ñ—è —Å—Ç—Ä—ñ–ª—å—Ü—è –Ω–∏–∂—á–µ
    
    this.bubbleTypes = ['blue', 'red', 'yellow', 'kyan', 'heart']; // –í—Å—ñ –∫–∞—Å—Ç–æ–º–Ω—ñ —Å–ø—Ä–∞–π—Ç–∏
    this.grid = [];
    this.shootingBubble = null;
    this.score = 0;
    this.gameMode = 'endless';
    this.timeLeft = 60;
    this.dropTimer = 10;
    this.lastTime = 0;
    this.isPaused = false;
    this.isGameOver = false;
    this.explodingBubbles = [];
    this.particles = [];
    
    // FPS tracking
    this.frameCount = 0;
    this.lastFPSUpdate = 0;
    this.currentFPS = 0;
    
    // === –ù–û–í–Ü –°–ò–°–¢–ï–ú–ò –î–õ–Ø –°–ö–õ–ê–î–ù–û–°–¢–Ü ===
    this.difficulty = 1; // –ü–æ—á–∞—Ç–∫–æ–≤–∞ —Å–∫–ª–∞–¥–Ω—ñ—Å—Ç—å
    this.difficultyMultiplier = 1; // –ú–Ω–æ–∂–Ω–∏–∫ —Å–∫–ª–∞–¥–Ω–æ—Å—Ç—ñ –¥–ª—è endless
    this.difficultyInterval = null; // –¢–∞–π–º–µ—Ä –ø—ñ–¥–≤–∏—â–µ–Ω–Ω—è —Å–∫–ª–∞–¥–Ω–æ—Å—Ç—ñ
    this.shotsCount = 0; // –õ—ñ—á–∏–ª—å–Ω–∏–∫ –ø–æ—Å—Ç—Ä—ñ–ª—ñ–≤
    this.consecutiveHits = 0; // –ü–æ—Å–ª—ñ–¥–æ–≤–Ω—ñ –≤–ª—É—á–µ–Ω–Ω—è
    this.bubbleGenerationCounter = 0; // –õ—ñ—á–∏–ª—å–Ω–∏–∫ –≥–µ–Ω–µ—Ä–∞—Ü—ñ–π
    this.recentColors = []; // –û—Å—Ç–∞–Ω–Ω—ñ –∫–æ–ª—å–æ—Ä–∏ –Ω–∞ –ø–æ–ª—ñ
    this.colorDistribution = new Map(); // –†–æ–∑–ø–æ–¥—ñ–ª –∫–æ–ª—å–æ—Ä—ñ–≤ –Ω–∞ –ø–æ–ª—ñ
    this.lastPatternType = null; // –û—Å—Ç–∞–Ω–Ω—ñ–π –∑–≥–µ–Ω–µ—Ä–æ–≤–∞–Ω–∏–π –ø–∞—Ç–µ—Ä–Ω
    
    this.bubbleImages = {};
    this.sounds = {};
    
    this.allowedBottomRows = 1; // –õ–∏—à–µ 1 —Ä—è–¥–æ–∫ –∑–∞–ø–∞—Å—É
    
    this.fps = 0;
    this.lastFpsUpdate = 0;
    this.frameCounter = 0;
    
    this.threatRowTimer = null;
    
    // üîç –ì–õ–û–ë–ê–õ–¨–ù–ê –°–ò–°–¢–ï–ú–ê –ú–û–ù–Ü–¢–û–†–ò–ù–ì–£ GRID
    this.gridMonitor = {
      enabled: true,
      operations: [],
      maxOperations: 500
    };
    
    this.createGrid();
    this.loadImages().then(() => {
      this.spawnShootingBubble();
    });
    this.initSounds();
    
    // –†–æ–±–∏–º–æ –≥—Ä—É –¥–æ—Å—Ç—É–ø–Ω–æ—é –≥–ª–æ–±–∞–ª—å–Ω–æ –¥–ª—è –≤—ñ–¥–ª–∞–¥–∫–∏
    if (typeof window !== 'undefined') {
      window.debugGame = this;
    }
  }

  async loadImages() {
    console.log('loadImages: Starting to load bubble images:', this.bubbleTypes);
    
    const imagePromises = this.bubbleTypes.map(type => {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => {
          console.log(`loadImages: Successfully loaded ${type}`);
          resolve({ type, img });
        };
        img.onerror = (error) => {
          console.error(`loadImages: Failed to load ${type}:`, error);
                     reject(error);
        };
        img.src = `/ball-${type}.png`;
        console.log(`loadImages: Loading ${type} from /ball-${type}.png`);
      });
    });

    try {
      const loadedImages = await Promise.all(imagePromises);
      loadedImages.forEach(({type, img}) => {
        this.bubbleImages[type] = img;
        console.log(`loadImages: Added ${type} to bubbleImages`);
      });
      console.log('loadImages: All images loaded successfully');
    } catch (error) {
      console.error('loadImages: Error loading images:', error);
    }
  }

  initSounds() {
    this.soundEnabled = true; // –°–ø–æ—á–∞—Ç–∫—É –∑–≤—É–∫–∏ –≤–∫–ª—é—á–µ–Ω—ñ
    try {
      this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
      this.loadSounds();
      console.log('Sounds initialized successfully');
      // === –ú—É–∑–∏–∫–∞ –¥–ª—è –≥–æ–ª–æ–≤–Ω–æ–≥–æ –º–µ–Ω—é –≤—ñ–¥–∫–ª—é—á–µ–Ω–∞ ===
      // if (!this.menuMusic) {
      //   this.menuMusic = new Audio('main-menu.mp3');
      //   this.menuMusic.loop = true;
      //   this.menuMusic.volume = 0.4;
      // }
    } catch (e) {
      console.warn('Audio not supported');
      this.soundEnabled = false;
    }
  }

  async loadSounds() {
    const soundFiles = ['shoot', 'pop', 'menu', 'game-over', 'start'];
    
    for (const soundName of soundFiles) {
      try {
        const audio = new Audio();
        audio.preload = 'auto';
        audio.volume = 0.3;
        // Fallback to generated sounds via Web Audio API
        this.sounds[soundName] = audio;
      } catch (e) {
        console.warn(`Could not load sound: ${soundName}`);
      }
    }
  }

  playSound(soundName) {
    console.log(`Trying to play sound: ${soundName}, soundEnabled: ${this.soundEnabled}`);
    if (!this.soundEnabled) {
      console.log('Sound disabled, not playing');
      return;
    }
    
    if (soundName === 'shoot') {
      this.generateAndPlayTone(800, 400, 0.2, 0.3, 'exponential');
    } else if (soundName === 'pop') {
      this.generateAndPlayTone(200, 1000, 0.3, 0.4, 'linear');
    } else if (soundName === 'menu') {
      console.log('Playing menu hover sound');
      this.generateAndPlayTone(600, 200, 0.15, 0.2, 'exponential');
    } else if (soundName === 'game-over') {
      this.generateAndPlayTone(400, -300, 1.0, 0.3, 'exponential');
    } else if (soundName === 'start') {
      this.generateAndPlayTone(300, 500, 0.8, 0.4, 'exponential');
    }
  }

  generateAndPlayTone(startFreq, freqChange, duration, volume, curve = 'exponential') {
    if (!this.audioContext) {
      console.warn('No audio context available');
      return;
    }
    
    try {
      // Ensure audio context is running
      if (this.audioContext.state === 'suspended') {
        this.audioContext.resume();
      }
      
      const oscillator = this.audioContext.createOscillator();
      const gainNode = this.audioContext.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(this.audioContext.destination);
      
      oscillator.frequency.setValueAtTime(startFreq, this.audioContext.currentTime);
      if (curve === 'exponential') {
        oscillator.frequency.exponentialRampToValueAtTime(
          startFreq + freqChange, 
          this.audioContext.currentTime + duration
        );
      } else {
        oscillator.frequency.linearRampToValueAtTime(
          startFreq + freqChange, 
          this.audioContext.currentTime + duration
        );
      }
      
      gainNode.gain.setValueAtTime(volume, this.audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);
      
      oscillator.start(this.audioContext.currentTime);
      oscillator.stop(this.audioContext.currentTime + duration);
      console.log(`Sound tone generated: freq ${startFreq}, duration ${duration}, volume ${volume}`);
    } catch (e) {
      console.warn('Could not play sound:', e);
    }
  }

  // üîç –°–ò–°–¢–ï–ú–ê –ì–õ–û–ë–ê–õ–¨–ù–û–ì–û –ú–û–ù–Ü–¢–û–†–ò–ù–ì–£ GRID
  logGridOperation(operation, row, col, oldValue, newValue, stackTrace = '') {
    if (!this.gridMonitor.enabled) return;
    
    const timestamp = Date.now();
    const operation_id = this.gridMonitor.operations.length;
    
    const logEntry = {
      id: operation_id,
      timestamp,
      operation,
      position: `${row},${col}`,
      oldValue: oldValue ? oldValue.type : 'NULL',
      newValue: newValue ? newValue.type : 'NULL',
      stackTrace: new Error().stack.split('\n').slice(2, 5).join('\n'), // 3 —Ä—ñ–≤–Ω—ñ —Å—Ç–µ–∫—É
      gameState: {
        explodingCount: this.explodingBubbles.length,
        totalBubbles: this.countTotalBubbles()
      }
    };
    
    console.log(`üîç GRID[${operation_id}]: ${operation} at ${row},${col} | ${oldValue ? oldValue.type : 'NULL'} ‚Üí ${newValue ? newValue.type : 'NULL'}`);
    
    this.gridMonitor.operations.push(logEntry);
    
    // –û–±–º–µ–∂—É—î–º–æ –∫—ñ–ª—å–∫—ñ—Å—Ç—å –æ–ø–µ—Ä–∞—Ü—ñ–π –≤ –ø–∞–º'—è—Ç—ñ
    if (this.gridMonitor.operations.length > this.gridMonitor.maxOperations) {
      this.gridMonitor.operations.shift();
    }
  }

  // –ë–µ–∑–ø–µ—á–Ω–µ –≤—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—è –∑–Ω–∞—á–µ–Ω–Ω—è –≤ grid –∑ –ª–æ–≥—É–≤–∞–Ω–Ω—è–º
  setGridSafely(row, col, value, operation = 'SET') {
    if (row < 0 || row >= this.rows || col < 0 || col >= this.cols) {
      console.error(`üö® INVALID GRID ACCESS: ${operation} at ${row},${col} - out of bounds!`);
      return false;
    }
    
    const oldValue = this.grid[row][col];
    this.logGridOperation(operation, row, col, oldValue, value);
    this.grid[row][col] = value;
    
    // –û–Ω–æ–≤–ª—é—î–º–æ –∫–µ—à
    this.updateActiveBubblesCache(row, col, value);
    
    return true;
  }

  // –ë–µ–∑–ø–µ—á–Ω–µ –æ—Ç—Ä–∏–º–∞–Ω–Ω—è –∑–Ω–∞—á–µ–Ω–Ω—è –∑ grid
  getGridSafely(row, col) {
    if (row < 0 || row >= this.rows || col < 0 || col >= this.cols) {
      return null;
    }
    return this.grid[row][col];
  }

  // –ü—ñ–¥—Ä–∞—Ö—É–Ω–æ–∫ –∑–∞–≥–∞–ª—å–Ω–æ—ó –∫—ñ–ª—å–∫–æ—Å—Ç—ñ –∫—É–ª—å–æ–∫
  countTotalBubbles() {
    let count = 0;
    for (let row = 0; row < this.rows; row++) {
      for (let col = 0; col < this.cols; col++) {
        if (this.grid[row][col]) count++;
      }
    }
    return count;
  }

  // –§—É–Ω–∫—Ü—ñ—è –¥–ª—è —à–≤–∏–¥–∫–æ–≥–æ –∞–Ω–∞–ª—ñ–∑—É –ø—Ä–æ–±–ª–µ–º (–≤–∏–∫–ª–∏–∫–∞—Ç–∏ –≤ –∫–æ–Ω—Å–æ–ª—ñ: game.analyzeGridProblem())
  analyzeGridProblem() {
    console.log('üîç PROBLEM ANALYSIS REPORT:');
    console.log('============================');
    
    // –û—Å—Ç–∞–Ω–Ω—ñ 20 –æ–ø–µ—Ä–∞—Ü—ñ–π
    console.log('üìã LAST 20 GRID OPERATIONS:');
    const recentOps = this.gridMonitor.operations.slice(-20);
    recentOps.forEach(op => {
      console.log(`[${op.id}] ${op.operation} at ${op.position}: ${op.oldValue} ‚Üí ${op.newValue}`);
    });
    
    // –ü–æ—Ç–æ—á–Ω–∏–π —Å—Ç–∞–Ω grid
    console.log('\nüéØ CURRENT GRID STATE:');
    for (let row = 0; row < this.rows; row++) {
      const rowData = [];
      for (let col = 0; col < this.cols; col++) {
        const bubble = this.grid[row][col];
        rowData.push(bubble ? bubble.type.substring(0,2) : '  ');
      }
      console.log(`Row ${row.toString().padStart(2)}: [${rowData.join('|')}]`);
    }
    
    // –ö—É–ª—å–∫–∏ —â–æ –≤–∏–±—É—Ö–∞—é—Ç—å
    console.log(`\nüí• EXPLODING BUBBLES (${this.explodingBubbles.length}):`);
    this.explodingBubbles.forEach(bubble => {
      console.log(`  ${bubble.row},${bubble.col} (${bubble.type}) - progress: ${bubble.progress.toFixed(2)}`);
    });
    
    // –ü–æ—à—É–∫ –Ω–µ–≤—ñ–¥–ø–æ–≤—ñ–¥–Ω–æ—Å—Ç–µ–π
    console.log('\nüö® LOOKING FOR MISMATCHES:');
    let mismatches = 0;
    this.explodingBubbles.forEach(exploding => {
      const gridBubble = this.getGridSafely(exploding.row, exploding.col);
      if (gridBubble && gridBubble.type !== exploding.type) {
        console.error(`  MISMATCH at ${exploding.row},${exploding.col}: exploding="${exploding.type}" vs grid="${gridBubble.type}"`);
        mismatches++;
      }
    });
    
    if (mismatches === 0) {
      console.log('  ‚úÖ No mismatches found');
    }
    
    return {
      recentOperations: recentOps,
      explodingBubbles: this.explodingBubbles,
      mismatches: mismatches,
      totalBubbles: this.countTotalBubbles()
    };
  }

  // –§—É–Ω–∫—Ü—ñ—è –¥–ª—è —à–≤–∏–¥–∫–∏—Ö –ø–µ—Ä–µ—Ö–æ–¥—ñ–≤ –≤ –≥—Ä—ñ –ë–ï–ó fade –µ—Ñ–µ–∫—Ç—ñ–≤
  smoothGameTransition(newContent, callback = null) {
    // –ú–∏—Ç—Ç—î–≤–∞ –∑–∞–º—ñ–Ω–∞ –∫–æ–Ω—Ç–µ–Ω—Ç—É –±–µ–∑ –∑–∞—Ç—Ä–∏–º–æ–∫
    this.container.innerHTML = newContent;
    if (callback) callback();
  }

  showModeSelection() {
    console.log('showModeSelection called');
    const content = `
      <div id="mode-selection" style="background:rgba(255,255,255,0.85); backdrop-filter:blur(10px); border:1px solid rgba(255,255,255,0.2); border-radius:20px; padding:32px; text-align:center; width:400px; margin:0 auto; box-shadow:0 16px 48px rgba(0,0,0,0.3), 0 8px 24px rgba(0,0,0,0.2), inset 0 1px 0 rgba(255,255,255,0.4); animation: slideInUp 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);">
        <h2 id="mode-title" style="margin:0 0 24px 0; color:#333; font-size:2rem; font-weight:bold; animation: bounceIn 1s ease-out 0.3s both; text-shadow: 0 2px 4px rgba(0,0,0,0.1);">üéÆ Select game mode</h2>
        <div style="display:flex; gap:12px; justify-content:center;">
          <button id="endless-mode" style="flex:1; padding:12px; font-size:1.1rem; border-radius:8px; border:none; background:#43cea2; color:#fff; font-weight:bold; cursor:pointer; transition:all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94); animation: slideInLeft 0.6s ease-out 0.5s both;">
            üéØ Endless mode
          </button>
          <button id="timed-mode" style="flex:1; padding:12px; font-size:1.1rem; border-radius:8px; border:none; background:#4096ee; color:#fff; font-weight:bold; cursor:pointer; transition:all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94); animation: slideInUp 0.6s ease-out 0.7s both;">
            ‚è±Ô∏è 1 minute
          </button>
          <button id="back-to-menu" style="flex:1; padding:12px; font-size:1.1rem; border-radius:8px; border:none; background:#e74c3c; color:#fff; font-weight:bold; cursor:pointer; transition:all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94); animation: slideInRight 0.6s ease-out 0.9s both;">
            üè† Back
          </button>
        </div>
        <div id="floating-bubbles" style="position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; overflow:hidden; border-radius:20px;">
        </div>
      </div>
    `;

    this.smoothGameTransition(content, () => {
      // –î–æ–¥–∞—î–º–æ hover –µ—Ñ–µ–∫—Ç–∏ —Ç–∞ –∑–≤—É–∫–∏
      const buttons = this.container.querySelectorAll('button');
      console.log(`Found ${buttons.length} buttons for mode selection`);
      buttons.forEach((button, index) => {
        console.log(`Adding hover events to button ${index}: ${button.id}`);
        button.onmouseover = () => {
          console.log(`Button ${button.id} hovered`);
          this.playSound('menu');
          button.style.transform = 'scale(1.05) translateY(-2px)';
          button.style.boxShadow = '0 8px 16px rgba(0,0,0,0.2)';
        };
        button.onmouseout = () => {
          button.style.transform = 'scale(1) translateY(0)';
          button.style.boxShadow = '0 4px 8px rgba(0,0,0,0.1)';
        };
      });

      this.container.querySelector('#endless-mode').onclick = () => {
        this.playSound('start');
        this.animateStartTransition(() => {
          this.gameMode = 'endless';
          this.init();
        });
      };
      
      this.container.querySelector('#timed-mode').onclick = () => {
        this.playSound('start');
        this.animateStartTransition(() => {
          this.gameMode = 'timed';
          this.timeLeft = 60;
      this.init();
        });
      };

      this.container.querySelector('#back-to-menu').onclick = () => {
        this.playSound('menu');
        if (typeof window.showMainMenu === 'function') {
          window.showMainMenu();
        }
      };

      // –î–æ–¥–∞—î–º–æ –∞–Ω—ñ–º–∞—Ü—ñ—é –ø–ª–∞–≤–∞—é—á–∏—Ö –∫—É–ª—å–æ–∫
      this.startFloatingBubblesAnimation();

      // –í—Å—Ç–∞–Ω–æ–≤–ª—é—î–º–æ —Ñ–æ–Ω —á–µ—Ä–µ–∑ main.js
      if (typeof window.setGlobalBackground === 'function') {
        window.setGlobalBackground();
      }
    });
  }

  animateStartTransition(callback) {
    const modeSelection = this.container.querySelector('#mode-selection');
    if (modeSelection) {
      modeSelection.style.animation = 'zoomOut 0.5s ease-in forwards';
      setTimeout(callback, 500);
    } else {
      callback();
    }
  }

  startFloatingBubblesAnimation() {
    const floatingContainer = this.container.querySelector('#floating-bubbles');
    if (!floatingContainer) return;

    // –°—Ç–≤–æ—Ä—é—î–º–æ 5 –ø–ª–∞–≤–∞—é—á–∏—Ö –∫—É–ª—å–æ–∫
    for (let i = 0; i < 5; i++) {
      setTimeout(() => {
        this.createFloatingBubble(floatingContainer);
      }, i * 800);
    }

    // –ü–µ—Ä—ñ–æ–¥–∏—á–Ω–æ –¥–æ–¥–∞—î–º–æ –Ω–æ–≤—ñ –∫—É–ª—å–∫–∏
    setInterval(() => {
      if (this.container.querySelector('#floating-bubbles')) {
        this.createFloatingBubble(floatingContainer);
      }
    }, 3000);
  }

  createFloatingBubble(container) {
    const colors = ['#43cea2', '#4096ee', '#e74c3c', '#f39c12', '#9b59b6'];
    const color = colors[Math.floor(Math.random() * colors.length)];
    const size = 20 + Math.random() * 20;
    const startX = Math.random() * 100;
    const duration = 8 + Math.random() * 4;
    
    const bubble = document.createElement('div');
    bubble.style.cssText = `
      position: absolute;
      width: ${size}px;
      height: ${size}px;
      background: radial-gradient(circle at 30% 30%, ${color}aa, ${color});
      border-radius: 50%;
      left: ${startX}%;
      bottom: -50px;
      animation: floatUp ${duration}s linear forwards;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      border: 2px solid rgba(255,255,255,0.3);
    `;
    
    container.appendChild(bubble);
    
    // –í–∏–¥–∞–ª—è—î–º–æ –∫—É–ª—å–∫—É –ø—ñ—Å–ª—è –∞–Ω—ñ–º–∞—Ü—ñ—ó
    setTimeout(() => {
      if (bubble.parentNode) {
        bubble.parentNode.removeChild(bubble);
      }
    }, duration * 1000);
  }

  init() {
    const gameWidth = 620;
    const playAreaWidth = 600;
    const gameHeight = 600;
    const totalBubblesWidth = this.cols * this.bubbleRadius * 2;
    const sidePadding = (gameWidth - totalBubblesWidth) / 2;
    
    const content = `
      <div style="width:${gameWidth}px; margin:0 auto;">
        <div class="game-header" style="background:rgba(255,255,255,0.85); backdrop-filter:blur(10px); border:1px solid rgba(255,255,255,0.2); border-radius:16px; box-shadow:0 8px 24px rgba(0,0,0,0.2), inset 0 1px 0 rgba(255,255,255,0.4); padding:12px 16px; margin-bottom:12px; display:flex; justify-content:space-between; align-items:center;">
          <div style="display:flex; gap:12px; align-items:center;">
            <span id="score" class="score-badge" style="display:inline-block; padding:8px 16px; font-size:1.1rem; border-radius:8px; background:#43cea2; color:#fff; font-weight:bold;">Score: 0</span>
            ${this.gameMode === 'timed' ? `<span id="timer" style="display:inline-block; padding:8px 16px; font-size:1.1rem; border-radius:8px; background:#FF6B6B; color:#fff; font-weight:bold;">Time: 60s</span>` : ''}
          </div>
          <button id="pause-btn" class="pause-btn" style="padding:8px 16px; font-size:1.1rem; border-radius:8px; border:none; background:#43cea2; color:#fff; font-weight:bold; cursor:pointer;">Pause</button>
      </div>
      <div style="position:relative;">
          <canvas id="game-canvas" width="${gameWidth}" height="${gameHeight}" style="background:#666; border-radius:12px;"></canvas>
        <div id="pause-menu" class="hidden">
          <h2>Paused</h2>
          <button id="resume-btn">Resume</button>
            <button id="exit-btn" style="background:#e74c3c; color:#fff;">üö™ Exit</button>
          </div>
          <div id="game-over" class="hidden" style="position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); background:rgba(255,255,255,0.85); backdrop-filter:blur(10px); border:1px solid rgba(255,255,255,0.2); padding:30px; border-radius:20px; text-align:center; box-shadow:0 16px 48px rgba(0,0,0,0.3), 0 8px 24px rgba(0,0,0,0.2), inset 0 1px 0 rgba(255,255,255,0.4);">
            <h2 style="margin:0 0 20px 0; color:#2C3E50;">Game Over!</h2>
            <p style="margin:0 0 25px 0; color:#7F8C8D;">Final Score: <span id="final-score">0</span></p>
            <div style="display:flex; flex-direction:column; gap:10px; align-items:center;">
              <button id="play-again-btn" style="padding:12px 30px; font-size:1.1rem; border-radius:12px; border:none; background:#43cea2; color:#fff; font-weight:bold; cursor:pointer; width:160px;">Play Again</button>
              <button id="back-to-menu-btn" style="padding:12px 30px; font-size:1.1rem; border-radius:12px; border:none; background:#e74c3c; color:#fff; font-weight:bold; cursor:pointer; width:160px;">Back to Menu</button>
            </div>
          </div>
        </div>
      </div>
    `;

    this.smoothGameTransition(content, () => {
      this.canvas = this.container.querySelector('#game-canvas');
      this.ctx = this.canvas.getContext('2d');
      this.pauseMenu = this.container.querySelector('#pause-menu');
      this.gameOverMenu = this.container.querySelector('#game-over');
      this.scoreEl = this.container.querySelector('#score');
      this.timerEl = this.gameMode === 'timed' ? this.container.querySelector('#timer') : null;
      this.playAreaWidth = playAreaWidth;
      this.sidePadding = sidePadding;
      this.shooterY = gameHeight - this.bubbleRadius * 1.5; // –û–ø—É—Å–∫–∞—î–º–æ —Å—Ç—Ä—ñ–ª–µ—Ü—å —Ç—Ä–æ—Ö–∏ –Ω–∏–∂—á–µ
      this.addEventListeners();
      this.createGrid();
      this.spawnShootingBubble();
      this.difficultyMultiplier = 1;
      if (this.difficultyInterval) clearInterval(this.difficultyInterval);
      this.startGame();
    });
  }

  addEventListeners() {
    this.container.querySelector('#pause-btn').onclick = () => this.pauseGame();
    this.container.querySelector('#resume-btn').onclick = () => this.resumeGame();
    this.container.querySelector('#exit-btn').onclick = () => this.exitGame();
    this.container.querySelector('#play-again-btn').onclick = () => this.showModeSelection();
    this.container.querySelector('#back-to-menu-btn').onclick = () => this.exitGame();
    this.canvas.addEventListener('mousemove', (e) => this.aim(e));
    this.canvas.addEventListener('click', (e) => this.shoot(e));
  }

  createGrid() {
    this.grid = [];
    for (let row = 0; row < this.rows; row++) {
      this.grid[row] = [];
      for (let col = 0; col < this.cols; col++) {
        this.grid[row][col] = null;
      }
    }
    // –ì–µ–Ω–µ—Ä—É—î–º–æ –Ω–∞ 3 —Ä—è–¥–∏ –º–µ–Ω—à–µ –¥–ª—è –≤–∏—â–æ–≥–æ —Ä–æ–∑—Ç–∞—à—É–≤–∞–Ω–Ω—è
    const startingRows = Math.max(1, this.rows - this.allowedBottomRows - 4); // –ë—É–ª–æ -1, —Ç–µ–ø–µ—Ä -4
    
    // –°–ø–æ—á–∞—Ç–∫—É —Å—Ç–≤–æ—Ä—é—î–º–æ –±–∞–∑–æ–≤—É —Å—Ç—Ä—É–∫—Ç—É—Ä—É –∑ –≥–∞—Ä–∞–Ω—Ç–æ–≤–∞–Ω–∏–º–∏ —à–∞—Ä–∏–∫–∞–º–∏
    this.createBalancedStructure(startingRows);
    
    // –ü–æ—Ç—ñ–º –¥–æ–¥–∞—î–º–æ –≤–∏–ø–∞–¥–∫–æ–≤—ñ —à–∞—Ä–∏–∫–∏ –¥–ª—è —Ä–æ–∑–Ω–æ–æ–±—Ä–∞–∑–Ω–æ—Å—Ç—ñ, —É–Ω–∏–∫–∞—é—á–∏ –≤–µ–ª–∏–∫–∏—Ö –ø—É—Å—Ç–æ—Ç
    this.fillEmptyAreas(startingRows);
    // –ß–∞—Å—Ç—ñ—à–µ –¥–æ–¥–∞—î–º–æ –∫–∞–º'—è–Ω—ñ –∫—É–ª—å–∫–∏ –¥–ª—è –±—ñ–ª—å—à –∑–∞–≥—Ä—É–∂–µ–Ω–æ–≥–æ –ø–æ–ª—è (1-2 –∑–∞–º—ñ—Å—Ç—å 0-1)
    const stoneCount = Math.random() < 0.7 ? (Math.random() < 0.5 ? 1 : 2) : 0; // 70% —à–∞–Ω—Å 1-2 –∫–∞–º–µ–Ω—ñ–≤
    let placed = 0;
    let attempts = 0;
    while (placed < stoneCount && attempts < 100) {
      const row = Math.floor(Math.random() * startingRows);
      const colsInRow = row % 2 === 0 ? this.cols : this.cols - 1;
      const col = Math.floor(Math.random() * colsInRow);
      if (this.grid[row][col] && this.grid[row][col].type !== 'stone') {
        this.grid[row][col] = {
          type: 'stone',
          row: row,
          col: col
        };
        placed++;
        console.log('STONE placed at', row, col);
      }
      attempts++;
    }
    this.updateColorDistribution();
    this.rebuildActiveBubblesCache();
  }

  // –°—Ç–≤–æ—Ä—é—î–º–æ –∑–±–∞–ª–∞–Ω—Å–æ–≤–∞–Ω—É –±–∞–∑–æ–≤—É —Å—Ç—Ä—É–∫—Ç—É—Ä—É
  createBalancedStructure(startingRows) {
    for (let row = 0; row < startingRows; row++) {
      const colsInRow = row % 2 === 0 ? this.cols : this.cols - 1;
      
      // –°—Ç–≤–æ—Ä—é—î–º–æ –ø–∞—Ç—Ç–µ—Ä–Ω –∑ —Ä–µ–≥—É–ª—è—Ä–Ω–∏–º–∏ —ñ–Ω—Ç–µ—Ä–≤–∞–ª–∞–º–∏
      for (let col = 0; col < colsInRow; col++) {
        // –ö–æ–∂–µ–Ω 2-–π —à–∞—Ä–∏–∫ —É —à–∞—Ö–æ–≤–æ–º—É –ø–æ—Ä—è–¥–∫—É - –≥–∞—Ä–∞–Ω—Ç–æ–≤–∞–Ω–∏–π
        const isGuaranteedPosition = (row + col) % 3 !== 2; // ~67% –ø–æ–∑–∏—Ü—ñ–π
        
        if (isGuaranteedPosition) {
          const bubbleType = this.selectBubbleTypeAvoidingSequence(row, col);
          this.grid[row][col] = {
            type: bubbleType,
            row: row,
            col: col
          };
        }
      }
    }
  }

  // –ó–∞–ø–æ–≤–Ω—é—î–º–æ –ø—É—Å—Ç—ñ –æ–±–ª–∞—Å—Ç—ñ, —É–Ω–∏–∫–∞—é—á–∏ –≤–µ–ª–∏–∫–∏—Ö –ø—É—Å—Ç–æ—Ç
  fillEmptyAreas(startingRows) {
    for (let row = 0; row < startingRows; row++) {
      const colsInRow = row % 2 === 0 ? this.cols : this.cols - 1;
      
      for (let col = 0; col < colsInRow; col++) {
        // –ü—Ä–æ–ø—É—Å–∫–∞—î–º–æ –≤–∂–µ –∑–∞–ø–æ–≤–Ω–µ–Ω—ñ –∫–ª—ñ—Ç–∏–Ω–∫–∏
        if (this.grid[row][col]) continue;
        
        // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —á–∏ —Å—Ç–≤–æ—Ä–∏—Ç—å –ø—É—Å—Ç–æ—Ç–∞ –≤–µ–ª–∏–∫—É –ø—É—Å—Ç—É—é –∑–æ–Ω—É
        const emptyNeighbors = this.countEmptyNeighbors(row, col);
        const shouldFill = emptyNeighbors >= 3 || Math.random() < 0.3;
        
        if (shouldFill) {
          const bubbleType = this.selectBubbleTypeAvoidingSequence(row, col);
          this.grid[row][col] = {
            type: bubbleType,
            row: row,
            col: col
          };
        }
      }
    }
  }

  // –†–∞—Ö—É—î –∫—ñ–ª—å–∫—ñ—Å—Ç—å –ø—É—Å—Ç–∏—Ö —Å—É—Å—ñ–¥—ñ–≤ –Ω–∞–≤–∫–æ–ª–æ –ø–æ–∑–∏—Ü—ñ—ó
  countEmptyNeighbors(row, col) {
    const neighbors = this.getNeighbors(row, col);
    let emptyCount = 0;
    
    for (const {r, c} of neighbors) {
      if (r >= 0 && r < this.rows && c >= 0 && c < this.cols) {
        if (!this.grid[r][c]) {
          emptyCount++;
        }
      } else {
        // –ü–æ–∑–∏—Ü—ñ—ó –∑–∞ –º–µ–∂–∞–º–∏ –ø–æ–ª—è —Ä–∞—Ö—É—î–º–æ —è–∫ –ø—É—Å—Ç—ñ
        emptyCount++;
      }
    }
    
    return emptyCount;
  }

  // –§—É–Ω–∫—Ü—ñ—è –¥–ª—è –≤–∏–±–æ—Ä—É —Ç–∏–ø—É –∫—É–ª—å–∫–∏, —É–Ω–∏–∫–∞—é—á–∏ –¥–æ–≤–≥–∏—Ö –ø–æ—Å–ª—ñ–¥–æ–≤–Ω–æ—Å—Ç–µ–π
  selectBubbleTypeAvoidingSequence(row, col) {
    const colorTypes = this.bubbleTypes.filter(t => t !== 'stone');
    const avoidTypes = new Set();
    
    // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—É –ø–æ—Å–ª—ñ–¥–æ–≤–Ω—ñ—Å—Ç—å –∑–ª—ñ–≤–∞
    let consecutiveCount = 0;
    let lastType = null;
    for (let checkCol = col - 1; checkCol >= 0; checkCol--) {
      if (this.grid[row][checkCol] && this.grid[row][checkCol].type !== 'stone') {
        if (lastType === null) {
          lastType = this.grid[row][checkCol].type;
          consecutiveCount = 1;
        } else if (this.grid[row][checkCol].type === lastType) {
          consecutiveCount++;
        } else {
          break;
        }
      } else {
        break;
      }
    }
    
    // –Ø–∫—â–æ —î 2+ –æ–¥–Ω–∞–∫–æ–≤–∏—Ö –ø—ñ–¥—Ä—è–¥ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–æ, —É–Ω–∏–∫–∞—î–º–æ —Ü—å–æ–≥–æ –∫–æ–ª—å–æ—Ä—É
    if (consecutiveCount >= 2 && lastType) {
      avoidTypes.add(lastType);
    }
    
    // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—É –ø–æ—Å–ª—ñ–¥–æ–≤–Ω—ñ—Å—Ç—å –∑–≤–µ—Ä—Ö—É
    consecutiveCount = 0;
    lastType = null;
    for (let checkRow = row - 1; checkRow >= 0; checkRow--) {
      if (this.grid[checkRow][col] && this.grid[checkRow][col].type !== 'stone') {
        if (lastType === null) {
          lastType = this.grid[checkRow][col].type;
          consecutiveCount = 1;
        } else if (this.grid[checkRow][col].type === lastType) {
          consecutiveCount++;
        } else {
          break;
        }
      } else {
        break;
      }
    }
    
    // –Ø–∫—â–æ —î 2+ –æ–¥–Ω–∞–∫–æ–≤–∏—Ö –ø—ñ–¥—Ä—è–¥ –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–æ, —É–Ω–∏–∫–∞—î–º–æ —Ü—å–æ–≥–æ –∫–æ–ª—å–æ—Ä—É
    if (consecutiveCount >= 2 && lastType) {
      avoidTypes.add(lastType);
    }
    
    // –í–∏–±–∏—Ä–∞—î–º–æ –∑ –¥–æ—Å—Ç—É–ø–Ω–∏—Ö –∫–æ–ª—å–æ—Ä—ñ–≤, —É–Ω–∏–∫–∞—é—á–∏ –ø—Ä–æ–±–ª–µ–º–Ω–∏—Ö
    const availableTypes = colorTypes.filter(type => !avoidTypes.has(type));
    
    if (availableTypes.length > 0) {
      return availableTypes[Math.floor(Math.random() * availableTypes.length)];
    }
    
    // –Ø–∫—â–æ –≤—Å—ñ –∫–æ–ª—å–æ—Ä–∏ –∑–∞–±–æ—Ä–æ–Ω–µ–Ω—ñ (—Ä—ñ–¥–∫—ñ—Å–Ω–∏–π –≤–∏–ø–∞–¥–æ–∫), –ø–æ–≤–µ—Ä—Ç–∞—î–º–æ –≤–∏–ø–∞–¥–∫–æ–≤–∏–π
    return colorTypes[Math.floor(Math.random() * colorTypes.length)];
  }

  // === –ù–û–í–ê –õ–û–ì–Ü–ö–ê –†–û–ó–£–ú–ù–û–á –ì–ï–ù–ï–†–ê–¶–Ü–á ===
  generateSmartStartingBubbles() {
    // –ì–µ–Ω–µ—Ä—É—î–º–æ —Ç—ñ–ª—å–∫–∏ 2-3 —Ä—è–¥–∏ –¥–ª—è –≤–∏—â–æ–≥–æ —Ä–æ–∑—Ç–∞—à—É–≤–∞–Ω–Ω—è —ñ –±—ñ–ª—å—à —Ä–∞—Å—Å—ñ—è–Ω–æ–≥–æ –ø–æ–ª—è
    const startingRows = Math.max(2, this.rows - this.allowedBottomRows - 4);
    
    // –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ —Ç—É –∂ –∑–±–∞–ª–∞–Ω—Å–æ–≤–∞–Ω—É –ª–æ–≥—ñ–∫—É
    this.createBalancedStructure(startingRows);
    this.fillEmptyAreas(startingRows);
    
    this.updateColorDistribution();
  }

  // –†–æ–∑—É–º–Ω–∏–π –≤–∏–±—ñ—Ä —Ç–∏–ø—É –∫—É–ª—å–∫–∏
  getSmartBubbleType(row, col, strategy = 'adaptive') {
    switch (strategy) {
      case 'balanced':
        return this.getBalancedBubbleType();
      case 'clustered':
        return this.getClusteredBubbleType(row, col);
      case 'challenging':
        return this.getChallengingBubbleType(row, col);
      case 'strategic':
        return this.getStrategicBubbleType();
      default:
        return this.getAdaptiveBubbleType(row, col);
    }
  }

  // –ó–±–∞–ª–∞–Ω—Å–æ–≤–∞–Ω–∏–π –≤–∏–±—ñ—Ä –∫–æ–ª—å–æ—Ä—É
  getBalancedBubbleType() {
    // stone –Ω–µ –º–æ–∂–µ –±—É—Ç–∏ –¥–ª—è –∑–≤–∏—á–∞–π–Ω–∏—Ö –∫—É–ª—å–æ–∫
    let minCount = Infinity;
    let rareColors = [];
    for (const type of this.bubbleTypes) {
      if (type === 'stone') continue;
      const count = this.colorDistribution.get(type) || 0;
      if (count < minCount) {
        minCount = count;
        rareColors = [type];
      } else if (count === minCount) {
        rareColors.push(type);
      }
    }
    return rareColors[Math.floor(Math.random() * rareColors.length)];
  }

  // –ö–ª–∞—Å—Ç–µ—Ä–Ω–∏–π –≤–∏–±—ñ—Ä (—Å—Ö–æ–∂—ñ –∫–æ–ª—å–æ—Ä–∏ –ø–æ—Ä—É—á)
  getClusteredBubbleType(row, col) {
    const neighbors = this.getNeighbors(row, col);
    const neighborColors = neighbors
      .filter(({r, c}) => this.grid[r] && this.grid[r][c] && this.grid[r][c].type !== 'stone')
      .map(({r, c}) => this.grid[r][c].type);
    if (neighborColors.length > 0) {
      if (Math.random() < 0.7) {
        return neighborColors[Math.floor(Math.random() * neighborColors.length)];
      }
    }
    // stone –Ω–µ –º–æ–∂–µ –±—É—Ç–∏ –¥–ª—è –∫–ª–∞—Å—Ç–µ—Ä–Ω–∏—Ö
    const colorTypes = this.bubbleTypes.filter(t => t !== 'stone');
    return colorTypes[Math.floor(Math.random() * colorTypes.length)];
  }

  // –°–∫–ª–∞–¥–Ω–∏–π –≤–∏–±—ñ—Ä (—É–Ω–∏–∫–∞—Ç–∏ –ª–µ–≥–∫–∏—Ö –∫–æ–º–±—ñ–Ω–∞—Ü—ñ–π)
  getChallengingBubbleType(row, col) {
    const neighbors = this.getNeighbors(row, col);
    const neighborColors = neighbors
      .filter(({r, c}) => this.grid[r] && this.grid[r][c] && this.grid[r][c].type !== 'stone')
      .map(({r, c}) => this.grid[r][c].type);
    const colorTypes = this.bubbleTypes.filter(t => t !== 'stone');
    const availableColors = colorTypes.filter(type => !neighborColors.includes(type));
    if (availableColors.length > 0) {
      return availableColors[Math.floor(Math.random() * availableColors.length)];
    }
    return colorTypes[Math.floor(Math.random() * colorTypes.length)];
  }

  // –°—Ç—Ä–∞—Ç–µ–≥—ñ—á–Ω–∏–π –≤–∏–±—ñ—Ä (–±–∞–∑—É—î—Ç—å—Å—è –Ω–∞ –∫—É–ª—å—Ü—ñ –≥—Ä–∞–≤—Ü—è)
  getStrategicBubbleType() {
    if (this.shootingBubble) {
      const currentType = this.shootingBubble.type;
      if (currentType === 'stone') return this.getBalancedBubbleType();
      if (Math.random() < 0.4) {
        return currentType;
      }
      if (Math.random() < 0.3) {
        return this.getBalancedBubbleType();
      }
    }
    const colorTypes = this.bubbleTypes.filter(t => t !== 'stone');
    return colorTypes[Math.floor(Math.random() * colorTypes.length)];
  }

  // –ê–¥–∞–ø—Ç–∏–≤–Ω–∏–π –≤–∏–±—ñ—Ä (–±–∞–∑—É—î—Ç—å—Å—è –Ω–∞ —Å–∫–ª–∞–¥–Ω–æ—Å—Ç—ñ)
  getAdaptiveBubbleType(row, col) {
    const difficultyFactor = Math.min(this.difficulty * this.difficultyMultiplier, 5);
    if (difficultyFactor < 2) {
      return this.getBalancedBubbleType();
    } else if (difficultyFactor < 3) {
      return Math.random() < Math.min(0.8 * this.difficultyMultiplier, 1) ? this.getBalancedBubbleType() : this.getClusteredBubbleType(row, col);
    } else if (difficultyFactor < 4) {
      return Math.random() < Math.min(0.8 * this.difficultyMultiplier, 1) ? this.getClusteredBubbleType(row, col) : this.getChallengingBubbleType(row, col);
    } else {
      // –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞ —Å–∫–ª–∞–¥–Ω—ñ—Å—Ç—å
      const strategies = ['challenging', 'strategic', 'clustered'];
      const strategy = strategies[Math.floor(Math.random() * strategies.length)];
      return this.getSmartBubbleType(row, col, strategy);
    }
  }

  // –û—Ç—Ä–∏–º–∞—Ç–∏ —Å—É—Å—ñ–¥—ñ–≤ –∫–ª—ñ—Ç–∏–Ω–∫–∏
  getNeighbors(row, col) {
    const isEvenRow = row % 2 === 0;
    return [
      {r: row-1, c: isEvenRow ? col-1 : col},
      {r: row-1, c: isEvenRow ? col : col+1},
      {r: row, c: col-1},
      {r: row, c: col+1},
      {r: row+1, c: isEvenRow ? col-1 : col},
      {r: row+1, c: isEvenRow ? col : col+1}
    ].filter(({r, c}) => r >= 0 && r < this.rows && c >= 0 && c < this.cols);
  }

  // –û–Ω–æ–≤–∏—Ç–∏ —Ä–æ–∑–ø–æ–¥—ñ–ª –∫–æ–ª—å–æ—Ä—ñ–≤
  updateColorDistribution() {
    this.colorDistribution.clear();
    
    for (let row = 0; row < this.rows; row++) {
      for (let col = 0; col < this.cols; col++) {
        if (this.grid[row][col]) {
          const type = this.grid[row][col].type;
          this.colorDistribution.set(type, (this.colorDistribution.get(type) || 0) + 1);
        }
      }
    }
  }

  // –î–∏–Ω–∞–º—ñ—á–Ω–µ –ø—ñ–¥–≤–∏—â–µ–Ω–Ω—è —Å–∫–ª–∞–¥–Ω–æ—Å—Ç—ñ
  updateDifficulty() {
    const baseScore = this.score;
    const newDifficulty = Math.floor(baseScore / 1000) + 1; // –ö–æ–∂–Ω—ñ 1000 –æ—á–æ–∫ = +1 —Å–∫–ª–∞–¥–Ω—ñ—Å—Ç—å
    
    // –î–æ–¥–∞—Ç–∫–æ–≤–∞ —Å–∫–ª–∞–¥–Ω—ñ—Å—Ç—å –∑–∞ –ø–æ—Å–ª—ñ–¥–æ–≤–Ω—ñ –≤–ª—É—á–µ–Ω–Ω—è
    if (this.consecutiveHits >= 5) {
      this.difficulty = Math.max(this.difficulty, newDifficulty + 1);
    } else {
      this.difficulty = newDifficulty;
    }
    
    // –û–±–º–µ–∂—É—î–º–æ –º–∞–∫—Å–∏–º–∞–ª—å–Ω—É —Å–∫–ª–∞–¥–Ω—ñ—Å—Ç—å
    this.difficulty = Math.min(this.difficulty, 6);
  }

  // –ì–µ–Ω–µ—Ä–∞—Ü—ñ—è —Å–ø–µ—Ü—ñ–∞–ª—å–Ω–∏—Ö –ø–∞—Ç–µ—Ä–Ω—ñ–≤
  generateSpecialPattern() {
    if (Math.random() > Math.max(0.3 * this.difficultyMultiplier, 1)) return;
    const patterns = ['wall', 'pyramid', 'checker', 'threat', 'stoneRow'];
    let availablePatterns = patterns.filter(p => p !== this.lastPatternType);
    if (availablePatterns.length === 0) {
      availablePatterns = patterns;
    }
    const pattern = availablePatterns[Math.floor(Math.random() * availablePatterns.length)];
    this.lastPatternType = pattern;
    switch (pattern) {
      case 'wall':
        this.generateWallPattern();
        break;
      case 'pyramid':
        this.generatePyramidPattern();
        break;
      case 'checker':
        this.generateCheckerPattern();
        break;
      case 'threat':
        this.generateThreatPattern();
        break;
      case 'stoneRow':
        this.generateStoneThreatRow();
        break;
    }
  }

  generateWallPattern() {
    // –°—Ç–≤–æ—Ä—é—î–º–æ —Å—Ç—ñ–Ω—É –∑ –æ–¥–Ω–æ–≥–æ –∫–æ–ª—å–æ—Ä—É –≤ —Ü–µ–Ω—Ç—Ä—ñ
    const startCol = Math.floor(this.cols * 0.3);
    const endCol = Math.floor(this.cols * 0.7);
    const wallColor = this.bubbleTypes[Math.floor(Math.random() * this.bubbleTypes.length)];
    
    for (let col = startCol; col < endCol; col++) {
      this.grid[0][col] = {
        type: wallColor,
        row: 0,
        col: col
      };
    }
  }

  generatePyramidPattern() {
    // –°—Ç–≤–æ—Ä—é—î–º–æ –ø—ñ—Ä–∞–º—ñ–¥—É –∑ —Ü–µ–Ω—Ç—Ä—É
    const centerCol = Math.floor(this.cols / 2);
    const pyramidColor = this.bubbleTypes[Math.floor(Math.random() * this.bubbleTypes.length)];
    
    // –¶–µ–Ω—Ç—Ä–∞–ª—å–Ω–∞ –∫—É–ª—å–∫–∞
    this.grid[0][centerCol] = {
      type: pyramidColor,
      row: 0,
      col: centerCol
    };
    
    // –ë–æ–∫–æ–≤—ñ –∫—É–ª—å–∫–∏
    if (centerCol > 0) {
      this.grid[0][centerCol - 1] = {
        type: pyramidColor,
        row: 0,
        col: centerCol - 1
      };
    }
    if (centerCol < this.cols - 1) {
      this.grid[0][centerCol + 1] = {
        type: pyramidColor,
        row: 0,
        col: centerCol + 1
      };
    }
  }

  generateCheckerPattern() {
    // –®–∞—Ö–æ–≤–∞ –¥–æ—à–∫–∞ –∑ –¥–≤–æ—Ö –∫–æ–ª—å–æ—Ä—ñ–≤
    const color1 = this.bubbleTypes[Math.floor(Math.random() * this.bubbleTypes.length)];
    let color2 = this.bubbleTypes[Math.floor(Math.random() * this.bubbleTypes.length)];
    while (color2 === color1) {
      color2 = this.bubbleTypes[Math.floor(Math.random() * this.bubbleTypes.length)];
    }
    
    for (let col = 0; col < this.cols; col++) {
      const color = col % 2 === 0 ? color1 : color2;
      this.grid[0][col] = {
        type: color,
        row: 0,
        col: col
      };
    }
  }

  generateThreatPattern() {
    // –°—Ç–≤–æ—Ä—é—î–º–æ –∑–∞–≥—Ä–æ–∑–ª–∏–≤–∏–π –ø–∞—Ç–µ—Ä–Ω - –∫—É–ª—å–∫–∏ –±–ª–∏–∑—å–∫–æ –¥–æ —Å–µ—Ä–µ–¥–∏–Ω–∏ –∑–Ω–∏–∑—É
    const dangerousColors = this.bubbleTypes.slice(); // –ö–æ–ø—ñ—è –≤—Å—ñ—Ö –∫–æ–ª—å–æ—Ä—ñ–≤
    const centerStart = Math.floor(this.cols * 0.25);
    const centerEnd = Math.floor(this.cols * 0.75);
    
    for (let col = centerStart; col < centerEnd; col++) {
      if (Math.random() < 0.8) { // 80% —à–∞–Ω—Å
        const color = dangerousColors[Math.floor(Math.random() * dangerousColors.length)];
        this.grid[0][col] = {
          type: color,
          row: 0,
          col: col
        };
      }
    }
  }

  generateStoneThreatRow() {
    // –†—è–¥ –∑ –∫–∞–º–µ–Ω—è–º–∏ —Ç–∞ –æ–¥–Ω–∏–º –∫–æ–ª—å–æ—Ä–æ–º
    const color = this.bubbleTypes[Math.floor(Math.random() * (this.bubbleTypes.length - 1))];
    for (let col = 0; col < this.cols; col++) {
      this.grid[0][col] = {
        type: Math.random() < 0.6 ? 'stone' : color,
        row: 0,
        col: col
      };
    }
  }

  createParticles(x, y, color, count = 10) {
    for (let i = 0; i < count; i++) {
      const angle = (Math.PI * 2 * i) / count;
      const speed = 2 + Math.random() * 2;
      this.particles.push({
        x,
        y,
        dx: Math.cos(angle) * speed,
        dy: Math.sin(angle) * speed,
        color,
        size: 3 + Math.random() * 3,
        life: 1,
        decay: 0.02 + Math.random() * 0.02
      });
    }
  }

  updateParticles(deltaTime) {
    this.particles = this.particles.filter(p => {
      p.x += p.dx * deltaTime * 60;
      p.y += p.dy * deltaTime * 60;
      p.life -= p.decay * deltaTime * 60;
      if (p.life > 0) {
        this.ctx.save();
        this.ctx.globalAlpha = p.life;
        this.ctx.beginPath();
        this.ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
        this.ctx.fillStyle = p.color;
        this.ctx.fill();
        this.ctx.restore();
        return true;
      }
      return false;
    });
  }

  spawnShootingBubble() {
    // stone –Ω–µ –º–æ–∂–µ –±—É—Ç–∏ –¥–ª—è —Å—Ç—Ä—ñ–ª—å—Ü—è
    let type;
    const colorTypes = this.bubbleTypes.filter(t => t !== 'stone');
    if (Math.random() < 0.6 && this.colorDistribution.size > 0) {
      const availableColors = Array.from(this.colorDistribution.keys()).filter(t => t !== 'stone');
      type = availableColors[Math.floor(Math.random() * availableColors.length)];
    } else {
      type = colorTypes[Math.floor(Math.random() * colorTypes.length)];
    }
    this.shootingBubble = {
      type,
      x: this.canvas.width / 2,
      y: this.shooterY,
      dx: 0,
      dy: 0,
      moving: false
    };
  }

  aim(e) {
    if (this.shootingBubble.moving) return;
    const rect = this.canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    const dx = mx - this.shootingBubble.x;
    const dy = my - this.shootingBubble.y;
    
    // Calculate angle but invert Y to make upward = negative
    this.shootingAngle = Math.atan2(-dy, dx);
    
    // Restrict angle to shoot only upwards (between 0.15œÄ and 0.85œÄ)
    if (this.shootingAngle > 0) {
      this.shootingAngle = Math.min(Math.PI * 0.85, this.shootingAngle);
    } else {
      this.shootingAngle = Math.max(-Math.PI * 0.85, this.shootingAngle);
    }
  }

  shoot(e) {
    if (this.shootingBubble.moving || this.isPaused || this.isGameOver) return;
    
    this.playSound('shoot');
    
    // –û–Ω–æ–≤–ª—é—î–º–æ –ª—ñ—á–∏–ª—å–Ω–∏–∫–∏
    this.shotsCount++;
    this.updateDifficulty();
    
    const speed = 850; // –ó–±—ñ–ª—å—à—É—î–º–æ —à–≤–∏–¥–∫—ñ—Å—Ç—å –∑ 780 –¥–æ 850 –¥–ª—è –∫—Ä–∞—â–æ–≥–æ –≤—ñ–¥—á—É—Ç—Ç—è
    this.shootingBubble.dx = Math.cos(this.shootingAngle) * speed;
    this.shootingBubble.dy = -Math.sin(Math.abs(this.shootingAngle)) * speed; // Negative for upward movement
    this.shootingBubble.moving = true;
  }

  startGame() {
    this.isPaused = false;
    this.score = 0;
    this.isGameOver = false;
    this.lastTime = 0;
    if (this.gameMode === 'timed') {
      this.timeLeft = 60;
      this.dropTimer = 10;
      this.updateTimer();
    }
    // === –î–æ–¥–∞—î–º–æ —Ç–∞–π–º–µ—Ä —Å–∫–ª–∞–¥–Ω–æ—Å—Ç—ñ –¥–ª—è endless ===
    if (this.gameMode === 'endless') {
      this.difficultyMultiplier = 1;
      if (this.difficultyInterval) clearInterval(this.difficultyInterval);
      this.difficultyInterval = setInterval(() => {
        this.difficultyMultiplier = Math.min(this.difficultyMultiplier * 1.5, 10);
        // –ú–æ–∂–Ω–∞ –ø–æ–∫–∞–∑–∞—Ç–∏ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –∞–±–æ –∞–Ω—ñ–º–∞—Ü—ñ—é –ø—Ä–æ –ø—ñ–¥–≤–∏—â–µ–Ω–Ω—è —Å–∫–ª–∞–¥–Ω–æ—Å—Ç—ñ
      }, 20000);
      if (this.threatRowTimer) clearInterval(this.threatRowTimer);
      this.threatRowTimer = setInterval(() => {
        this.generateStoneThreatRow();
      }, 35000); // –∫–æ–∂–Ω—ñ 35 —Å–µ–∫—É–Ω–¥
    }
    this.updateScore();
    requestAnimationFrame((time) => this.loop(time));

    // –ó—É–ø–∏–Ω—è—î–º–æ –º—É–∑–∏–∫—É –≥–æ–ª–æ–≤–Ω–æ–≥–æ –º–µ–Ω—é
    if (this.menuMusic && !this.menuMusic.paused) {
      this.menuMusic.pause();
      this.menuMusic.currentTime = 0;
    }

    // –í—Å—Ç–∞–Ω–æ–≤–ª—é—î–º–æ —Ñ–æ–Ω –ø—ñ–¥ —á–∞—Å –≥—Ä–∏
    if (typeof window.setGlobalBackground === 'function') {
      window.setGlobalBackground();
    }
  }

  loop(currentTime) {
    if (this.isPaused || this.isGameOver) return;
    if (!this.lastTime) this.lastTime = currentTime;
    const deltaTime = (currentTime - this.lastTime) / 1000;
    this.lastTime = currentTime;
    // FPS
    this.frameCounter++;
    if (currentTime - this.lastFpsUpdate > 1000) {
      this.fps = this.frameCounter;
      this.frameCounter = 0;
      this.lastFpsUpdate = currentTime;
    }
    // Game mode logic
    if (this.gameMode === 'timed') {
      this.timeLeft -= deltaTime;
      this.dropTimer -= deltaTime;
      this.updateTimer();
      
      if (this.dropTimer <= 0) {
        this.dropBubblesOneRow();
        this.dropTimer = 10;
      }
      
      if (this.timeLeft <= 0) {
        this.gameOver();
        return;
      }
    }
    
    // Update explosion animations with optimized deltaTime
    if (this.explodingBubbles.length > 0) {
      const explosionSpeed = deltaTime * 5.0; // –ü—Ä–∏—Å–∫–æ—Ä—é—î–º–æ –∞–Ω—ñ–º–∞—Ü—ñ—é
      
      for (let i = this.explodingBubbles.length - 1; i >= 0; i--) {
        const b = this.explodingBubbles[i];
        b.progress += explosionSpeed;
        
        // Create particles only once at start
        if (b.progress < 0.15 && !b.particlesCreated) {
          const {x, y} = this.gridToPixel(b.row, b.col);
          // –û—Ç—Ä–∏–º—É—î–º–æ –∫–æ–ª—ñ—Ä –¥–ª—è —Ç–∏–ø—É –∫—É–ª—ñ
          const colors = {
            'blue': '#4A90E2',
            'red': '#E74C3C',
            'yellow': '#F1C40F',
            'kyan': '#1ABC9C',
            'heart': '#FF69B4'
          };
          const color = colors[b.type] || '#999999';
          this.createParticles(x, y, color, 6); // Fewer particles for performance
          b.particlesCreated = true;
        }
        
        // Remove completed explosions immediately
        if (b.progress >= 1) {
          // –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ –±–µ–∑–ø–µ—á–Ω—ñ —Ñ—É–Ω–∫—Ü—ñ—ó –∑ –ª–æ–≥—É–≤–∞–Ω–Ω—è–º
          const currentBubble = this.getGridSafely(b.row, b.col);
          
          // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ —á–∏ –Ω–µ –±—É–ª–∞ –≤–∂–µ –≤–∏–¥–∞–ª–µ–Ω–∞ —Ü—è –∫—É–ª—è –≤ —ñ–Ω—à–æ–º—É –º—ñ—Å—Ü—ñ
          if (currentBubble && currentBubble.type === b.type) {
            console.log(`‚úÖ EXPLOSION: Removing exploded bubble at ${b.row},${b.col} of type "${b.type}"`);
            this.setGridSafely(b.row, b.col, null, 'REMOVE_EXPLODED');
          } else if (!currentBubble) {
            console.log(`‚ö†Ô∏è EXPLOSION: Bubble at ${b.row},${b.col} already removed (probably floating bubble), skipping`);
          } else {
            // –°–ø—Ä–∞–≤–∂–Ω—è –ø–æ–º–∏–ª–∫–∞ - –∫—É–ª—è —ñ–Ω—à–æ–≥–æ —Ç–∏–ø—É –Ω–∞ —Ü—ñ–π –ø–æ–∑–∏—Ü—ñ—ó
            const currentType = currentBubble.type;
            console.error(`üö® CRITICAL: Explosion cleanup type mismatch at ${b.row},${b.col}! Expected: "${b.type}", Found: "${currentType}"`);
            
            // –í–∏–≤–æ–¥–∏–º–æ –æ—Å—Ç–∞–Ω–Ω—ñ –æ–ø–µ—Ä–∞—Ü—ñ—ó –¥–ª—è –¥—ñ–∞–≥–Ω–æ—Å—Ç–∏–∫–∏
            console.error(`üö® EXPLOSION ERROR - Last 15 grid operations:`, this.gridMonitor.operations.slice(-15));
            
            // –ü–æ–∫–∞–∑—É—î–º–æ –¥–µ—Ç–∞–ª—å–Ω—É —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—é –ø—Ä–æ –ø—Ä–æ–±–ª–µ–º–Ω—É –ø–æ–∑–∏—Ü—ñ—é
            console.error(`üö® EXPLOSION ERROR - Exploding bubble details:`, {
              row: b.row,
              col: b.col,
              expectedType: b.type,
              actualType: currentType,
              progress: b.progress
            });
            
            // –ù–ï –≤–∏–¥–∞–ª—è—î–º–æ –∫—É–ª—é —è–∫—â–æ –≤–æ–Ω–∞ —ñ–Ω—à–æ–≥–æ —Ç–∏–ø—É - —Ü–µ –º–æ–∂–µ –ø–æ—à–∫–æ–¥–∏—Ç–∏ –≥—Ä—É
            console.error(`üö® EXPLOSION ERROR: NOT removing bubble due to type mismatch!`);
            
            this.debugGridIntegrity('after_explosion_type_mismatch');
          }
          this.explodingBubbles.splice(i, 1);
        }
      }
    }
    
    // Clear canvas once per frame
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    
    // Optimized render calls
    this.drawGrid();
    this.drawShootingBubble();
    this.drawAimLine();
    
    // Update systems
    this.updateShootingBubble(deltaTime);
    this.updateParticles(deltaTime);
    
    // Draw FPS
    this.drawFPS();
    
    // Next frame
    requestAnimationFrame((time) => this.loop(time));
  }

  updateTimer() {
    if (this.timerEl) {
      const seconds = Math.max(0, Math.ceil(this.timeLeft));
      this.timerEl.textContent = `Time: ${seconds}s`;
    }
  }

  drawGrid() {
    for (let row = 0; row < this.rows; row++) {
      for (let col = 0; col < this.cols; col++) {
        const bubble = this.grid[row][col];
        if (bubble) {
          // –Ø–∫—â–æ –∫—É–ª—å–∫–∞ –≤–∏–±—É—Ö–∞—î ‚Äî –º–∞–ª—é—î–º–æ –∑ –∞–Ω—ñ–º–∞—Ü—ñ—î—é
          const exploding = this.explodingBubbles.find(b => b.row === row && b.col === col);
          if (exploding) {
            const { x, y } = this.gridToPixel(row, col);
            this.drawBubbleAnimated(x, y, bubble.type, exploding.progress);
          } else {
          const { x, y } = this.gridToPixel(row, col);
            this.drawBubble(x, y, bubble.type);
          }
        }
      }
    }
  }

  drawBubble(x, y, type) {
    this.ctx.save();
    
    // –ö–æ–ª—å–æ—Ä–∏ –¥–ª—è –∫—É–ª—å–æ–∫
    const colors = {
      'blue': '#4A90E2',
      'red': '#E74C3C',
      'yellow': '#F1C40F',
      'kyan': '#1ABC9C',
      'heart': '#FF69B4'
    };
    
    // –¢—ñ–Ω—å –¥–ª—è –∫—É–ª—å–∫–∏
    this.ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
    this.ctx.shadowBlur = 8;
    this.ctx.shadowOffsetY = 2;
    
    // –û—Å–Ω–æ–≤–Ω–∞ –∫—É–ª—å–∫–∞
    const color = colors[type] || '#999999';
    this.ctx.fillStyle = color;
    this.ctx.beginPath();
    this.ctx.arc(x, y, this.bubbleRadius, 0, Math.PI * 2);
    this.ctx.fill();
    
    // –ì–ª—è–Ω–µ—Ü—å
    this.ctx.shadowColor = 'transparent';
    this.ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
    this.ctx.beginPath();
    this.ctx.arc(x - 6, y - 6, this.bubbleRadius / 2.5, 0, Math.PI * 2);
    this.ctx.fill();
    
    // –†–∞–º–∫–∞
    this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
    this.ctx.lineWidth = 1;
    this.ctx.beginPath();
    this.ctx.arc(x, y, this.bubbleRadius, 0, Math.PI * 2);
    this.ctx.stroke();
    
    // –°–ø—Ä–∞–π—Ç –≤—Å–µ—Ä–µ–¥–∏–Ω—ñ –∫—É–ª—å–∫–∏ (—è–∫—â–æ —î)
    if (this.bubbleImages[type]) {
      // –ó–±–µ—Ä—ñ–≥–∞—î–º–æ —Å—Ç–∞–Ω –±–µ–∑ —Ç—ñ–Ω—ñ –¥–ª—è —Å–ø—Ä–∞–π—Ç—É
      this.ctx.shadowColor = 'transparent';
      
      // –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è –¥–ª—è –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ—ó —è–∫–æ—Å—Ç—ñ —Å–ø—Ä–∞–π—Ç—ñ–≤
      this.ctx.imageSmoothingEnabled = false; // –ß—ñ—Ç–∫–µ –≤—ñ–¥–æ–±—Ä–∞–∂–µ–Ω–Ω—è
      
      // –†–æ–∑–º—ñ—Ä —Å–ø—Ä–∞–π—Ç—É - –∑–º–µ–Ω—à–µ–Ω–∏–π –¥–ª—è –∫—Ä–∞—â–æ–≥–æ –≤–∏–≥–ª—è–¥—É
      const spriteSize = Math.round(this.bubbleRadius * 1.2); // –ó–º–µ–Ω—à—É—î–º–æ –¥–æ 26.4, –æ–∫—Ä—É–≥–ª—é—î–º–æ –¥–æ 26
      const spritePosX = Math.round(x - spriteSize / 2);
      const spritePosY = Math.round(y - spriteSize / 2);
      
      this.ctx.drawImage(
        this.bubbleImages[type],
        spritePosX,
        spritePosY,
        spriteSize,
        spriteSize
      );
    }
    
    this.ctx.restore();
  }

  drawBubbleAnimated(x, y, type, progress) {
    this.ctx.save();
    // Easing: scale —Ç–∞ opacity
    const scale = 1 + 0.5 * Math.sin(Math.PI * progress);
    const alpha = 1 - progress;
    this.ctx.globalAlpha = alpha;
    this.ctx.translate(x, y);
    this.ctx.scale(scale, scale);
    this.ctx.translate(-x, -y);
    this.drawBubble(x, y, type);
    this.ctx.restore();
  }

  gridToPixel(row, col) {
    const evenRow = row % 2 === 0;
    const bubbleSpacing = this.bubbleRadius * 2.1; // –ó–±—ñ–ª—å—à—É—î–º–æ –ø—Ä–æ—Å—Ç—ñ—Ä –º—ñ–∂ –∫—É–ª—å–∫–∞–º–∏
    const x = this.sidePadding + (evenRow ? 0 : this.bubbleRadius) + col * bubbleSpacing;
    const y = row * this.bubbleRadius * 1.9 + this.bubbleRadius + 20; // –ë—ñ–ª—å—à–∏–π –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–∏–π –ø—Ä–æ—Å—Ç—ñ—Ä
    return { x, y };
  }

  pixelToGrid(x, y) {
    const bubbleSpacing = this.bubbleRadius * 2.1;
    const row = Math.floor((y - this.bubbleRadius - 20) / (this.bubbleRadius * 1.9));
    const evenRow = row % 2 === 0;
    const col = Math.floor((x - this.sidePadding - (evenRow ? 0 : this.bubbleRadius)) / bubbleSpacing);
    return { row, col };
  }

  drawShootingBubble() {
    if (this.isGameOver || !this.shootingBubble) return;
    
    this.ctx.save();
    if (this.shootingBubble.moving) {
      // Add motion blur effect
      this.ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';
      this.ctx.shadowBlur = 16;
      this.ctx.globalAlpha = 0.96;
    }
    
    this.drawBubble(
      this.shootingBubble.x,
      this.shootingBubble.y,
      this.shootingBubble.type
    );
    
    this.ctx.restore();
  }

  drawAimLine() {
    if (!this.shootingBubble.moving) {
      this.ctx.save();
      this.ctx.strokeStyle = 'rgba(150, 150, 150, 0.8)';
      this.ctx.lineWidth = 2;
      this.ctx.setLineDash([8, 4]);
      this.ctx.beginPath();
      this.ctx.moveTo(this.shootingBubble.x, this.shootingBubble.y);
      
      // Draw aim line upward
      const lineLength = 200;
      const tx = this.shootingBubble.x + Math.cos(this.shootingAngle) * lineLength;
      const ty = this.shootingBubble.y - Math.sin(Math.abs(this.shootingAngle)) * lineLength;
      
      this.ctx.lineTo(tx, ty);
      this.ctx.stroke();
      this.ctx.setLineDash([]);
      this.ctx.restore();
    }
  }

  updateShootingBubble(deltaTime) {
    if (!this.shootingBubble || this.isGameOver) return;
    const prevX = this.shootingBubble.x;
    const prevY = this.shootingBubble.y;
    this.shootingBubble.x += this.shootingBubble.dx * deltaTime;
    this.shootingBubble.y += this.shootingBubble.dy * deltaTime;
    // Calculate boundaries with proper spacing
    const gridWidth = this.cols * (this.bubbleRadius * 2 + 6);
    const padding = (this.playAreaWidth - gridWidth) / 2 + this.sidePadding;
    const leftBoundary = padding + this.bubbleRadius;
    const rightBoundary = this.canvas.width - padding - this.bubbleRadius;
    
    if (this.shootingBubble.x <= leftBoundary || 
        this.shootingBubble.x >= rightBoundary) {
      // Restore position and reverse X direction
      this.shootingBubble.x = prevX;
      this.shootingBubble.dx *= -1;
    }

    // Check if bubble hit the top edge
    if (this.shootingBubble.y <= this.bubbleRadius) {
      const col = Math.round((this.shootingBubble.x - this.bubbleRadius - padding) / (this.bubbleRadius * 2));
      
      if (col >= 0 && col < this.cols && !this.grid[0][col]) {
        this.attachBubbleToGrid(0, col);
      } else {
        this.gameOver();
      }
      return;
    }

    // OPTIMIZED: Use new collision detection system
    const collision = this.checkCollisionOptimized(this.shootingBubble.x, this.shootingBubble.y, prevX, prevY);
    if (collision) {
      // –ó–Ω–∞—Ö–æ–¥–∏–º–æ –≤—Å—ñ —Å—É—Å—ñ–¥–Ω—ñ –∫–ª—ñ—Ç–∏–Ω–∫–∏ –Ω–∞–≤–∫–æ–ª–æ —Ç–æ—á–∫–∏ –∑—ñ—Ç–∫–Ω–µ–Ω–Ω—è
      const neighborOffsets = [
        {dr: 1, dc: 0},
        {dr: 1, dc: -1},
        {dr: 1, dc: 1},
        {dr: 0, dc: -1},
        {dr: 0, dc: 1},
        {dr: -1, dc: 0}
      ];
      const isEvenRow = collision.row % 2 === 0;
      const neighborCoords = [
        {row: collision.row + 1, col: collision.col},
        {row: collision.row + 1, col: isEvenRow ? collision.col - 1 : collision.col + 1},
        {row: collision.row, col: collision.col - 1},
        {row: collision.row, col: collision.col + 1},
        {row: collision.row - 1, col: collision.col},
        {row: collision.row - 1, col: isEvenRow ? collision.col - 1 : collision.col + 1}
      ];
      // –ó–Ω–∞—Ö–æ–¥–∏–º–æ –Ω–∞–π–±–ª–∏–∂—á—É –≤—ñ–ª—å–Ω—É –∫–ª—ñ—Ç–∏–Ω–∫—É
      let minDist = Infinity;
      let bestPos = null;
      for (const pos of neighborCoords) {
        if (
          pos.row >= 0 && pos.row < this.rows &&
          pos.col >= 0 && pos.col < this.cols &&
          !this.grid[pos.row][pos.col]
        ) {
          const {x, y} = this.gridToPixel(pos.row, pos.col);
          const dx = this.shootingBubble.x - x;
          const dy = this.shootingBubble.y - y;
          const dist = dx * dx + dy * dy;
          if (dist < minDist) {
            minDist = dist;
            bestPos = pos;
          }
        }
      }
      if (bestPos) {
        this.attachBubbleToGrid(bestPos.row, bestPos.col);
        return;
      } else {
        // –Ø–∫—â–æ –Ω–µ–º–∞—î –≤—ñ–ª—å–Ω–æ–≥–æ –º—ñ—Å—Ü—è —Å–µ—Ä–µ–¥ —Å—É—Å—ñ–¥—ñ–≤ ‚Äî —à—É–∫–∞—î–º–æ –Ω–∞–π–Ω–∏–∂—á—É –≤—ñ–ª—å–Ω—É –∫–ª—ñ—Ç–∏–Ω–∫—É —É —Ü—ñ–π –∫–æ–ª–æ–Ω—Ü—ñ
        let fallbackRow = null;
        for (let row = this.rows - 1; row >= 0; row--) {
          if (!this.grid[row][collision.col]) {
            fallbackRow = row;
            break;
          }
        }
        if (fallbackRow !== null) {
          this.attachBubbleToGrid(fallbackRow, collision.col);
          return;
        }
        this.gameOver();
        this.shootingBubble = null;
        return;
      }
    }

    // Check if bubble went out of bounds at the bottom
    if (this.shootingBubble.y > this.canvas.height) {
      this.spawnShootingBubble();
    }
  }

  attachBubbleToGrid(hitRow, hitCol) {
    if (hitRow >= 0 && hitRow < this.rows && hitCol >= 0 && hitCol < this.cols) {
      if (hitRow >= this.rows - this.allowedBottomRows) {
        this.gameOver();
        this.shootingBubble = null;
        return;
      }
      
      // –î–æ–¥–∞—Ç–∫–æ–≤–∞ –ø–µ—Ä–µ–≤—ñ—Ä–∫–∞ —â–æ –ø–æ–∑–∏—Ü—ñ—è –¥—ñ–π—Å–Ω–æ –≤—ñ–ª—å–Ω–∞
      const currentBubble = this.getGridSafely(hitRow, hitCol);
      if (currentBubble) {
        console.error(`üö® CRITICAL: Trying to attach bubble to occupied position ${hitRow},${hitCol}! Current type: "${currentBubble.type}"`);
        this.gameOver();
        this.shootingBubble = null;
        return;
      }
      
      // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ —â–æ —Ü—è –ø–æ–∑–∏—Ü—ñ—è –Ω–µ –≤ –ø—Ä–æ—Ü–µ—Å—ñ –≤–∏–±—É—Ö—É
      const isExploding = this.explodingBubbles.some(bubble => 
        bubble.row === hitRow && bubble.col === hitCol
      );
      
      if (isExploding) {
        console.error(`üö® CRITICAL: Trying to attach bubble to exploding position ${hitRow},${hitCol}!`);
        this.gameOver();
        this.shootingBubble = null;
        return;
      }
      
      console.log(`SAFE: Attaching ${this.shootingBubble.type} bubble to position ${hitRow},${hitCol}`);
      
      const newBubble = {
        type: this.shootingBubble.type,
        row: hitRow,
        col: hitCol
      };
      
      this.setGridSafely(hitRow, hitCol, newBubble, 'ATTACH_BUBBLE');
      
      // –î–µ—Ç–∞–ª—å–Ω–∞ –ø–µ—Ä–µ–≤—ñ—Ä–∫–∞ —Å—É—Å—ñ–¥—ñ–≤ –ø–µ—Ä–µ–¥ –ø–æ—à—É–∫–æ–º –≥—Ä—É–ø
      this.debugNeighbors(hitRow, hitCol);
      
      // –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ –ù–û–í–£ –ë–ï–ó–ü–ï–ß–ù–£ —Ñ—É–Ω–∫—Ü—ñ—é –ø–æ—à—É–∫—É –≥—Ä—É–ø
      const matches = this.findGroupsSafely(hitRow, hitCol);
      
      // console.log(`attachBubbleToGrid: Found ${matches.length} matches for bubble type "${this.grid[hitRow][hitCol].type}" at ${hitRow},${hitCol}`);
      
      if (matches.length >= 3) {
        this.playSound('pop');
        let points = 0;
        if (matches.length === 3) points = 30;
        else if (matches.length === 4) points = 50;
        else if (matches.length >= 5) points = 100;
        this.score += points;
        // –û–Ω–æ–≤–ª—é—î–º–æ –ª—ñ—á–∏–ª—å–Ω–∏–∫–∏
        this.consecutiveHits++;
        this.updateDifficulty();
        this.updateScore();
        
        // –ü—ñ–¥–≥–æ—Ç–æ–≤–∫–∞ –µ—Ñ–µ–∫—Ç—É –≤–∏–±—É—Ö—É –ë–ï–ó –≤–∏–¥–∞–ª–µ–Ω–Ω—è –∑ grid (—Ü–µ —Ä–æ–±–∏—Ç—å—Å—è –ø—ñ–∑–Ω—ñ—à–µ –≤ loop)
        // –§—ñ–ª—å—Ç—Ä—É—î–º–æ —Ç—ñ–ª—å–∫–∏ –¥—ñ–π—Å–Ω—ñ —à–∞—Ä–∏–∫–∏
        const validMatches = matches.filter((match) => {
          // –ü–æ–¥–≤—ñ–π–Ω–∞ –ø–µ—Ä–µ–≤—ñ—Ä–∫–∞ —â–æ —Ü–µ –ø—Ä–∞–≤–∏–ª—å–Ω–∏–π —Ç–∏–ø —ñ –ø–æ–∑–∏—Ü—ñ—è
          if (this.grid[match.row] && this.grid[match.row][match.col] && 
              this.grid[match.row][match.col].type === match.type) {
            
            match.explosionDelay = Math.random() * 0.2;
            match.particlesCreated = false; // –î–ª—è –æ–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—ó
            
            console.log(`Preparing explosion for bubble at ${match.row},${match.col} of type "${match.type}"`);
            
            // –ù–ï –≤–∏–¥–∞–ª—è—î–º–æ —Ç—É—Ç! –¶–µ —Ä–æ–±–∏—Ç—å—Å—è –≤ loop() –ø—ñ—Å–ª—è –∞–Ω—ñ–º–∞—Ü—ñ—ó
            return true;
          } else {
            console.warn(`Skipping invalid match at ${match.row},${match.col} - bubble type mismatch`);
            return false;
          }
        });
        
        // –î–û–î–ê–Ñ–ú–û –¥–æ —ñ—Å–Ω—É—é—á–∏—Ö explodingBubbles –∑–∞–º—ñ—Å—Ç—å –∑–∞–º—ñ–Ω–∏
        this.explodingBubbles = [...this.explodingBubbles, ...validMatches];
        
        // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ —Ü—ñ–ª—ñ—Å–Ω—ñ—Å—Ç—å –ø—ñ—Å–ª—è –¥–æ–¥–∞–≤–∞–Ω–Ω—è –≥—Ä—É–ø–∏ –¥–æ –≤–∏–±—É—Ö—É
        this.debugGridIntegrity('after_adding_exploding_group');
        
        this.checkFloatingBubbles();
      } else {
        // Reset consecutive hits if no match
        this.consecutiveHits = 0;
        // console.log('No valid group found (less than 3 bubbles)');
      }
      // –û–Ω–æ–≤–ª—é—î–º–æ —Ä–æ–∑–ø–æ–¥—ñ–ª –∫–æ–ª—å–æ—Ä—ñ–≤
      this.updateColorDistribution();
      this.spawnShootingBubble();
    }
  }

  // –ù–û–í–ê –ë–ï–ó–ü–ï–ß–ù–ê –§–£–ù–ö–¶–Ü–Ø –¥–ª—è –ø–æ—à—É–∫—É –ø–ª–∞–≤–∞—é—á–∏—Ö –∫—É–ª—å–æ–∫
  findFloatingBubblesSafely() {
    console.log(`üõ°Ô∏è SAFE_FLOATING: Starting safe floating bubble detection`);
    
    // –°—Ç–≤–æ—Ä—é—î–º–æ –ü–û–í–ù–£ –ö–û–ü–Ü–Æ grid
    const gridCopy = this.grid.map(row => 
      row.map(cell => cell ? { ...cell } : null)
    );
    
    // –°—Ç–≤–æ—Ä—é—î–º–æ –º–Ω–æ–∂–∏–Ω—É —à–∞—Ä–∏–∫—ñ–≤ —â–æ –≤–∏–±—É—Ö–∞—é—Ç—å
    const explodingPositions = new Set();
    this.explodingBubbles.forEach(bubble => {
      explodingPositions.add(`${bubble.row},${bubble.col}`);
    });
    
    // –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ —Å—Ç–µ–∫ –¥–ª—è –∑–Ω–∞—Ö–æ–¥–∂–µ–Ω–Ω—è –∑'—î–¥–Ω–∞–Ω–∏—Ö –∫—É–ª—å–æ–∫
    const connected = new Set();
    const stack = [];
    
    // –î–æ–¥–∞—î–º–æ –≤—Å—ñ –∫—É–ª—å–∫–∏ –∑ –≤–µ—Ä—Ö–Ω—å–æ–≥–æ —Ä—è–¥—É –¥–æ —Å—Ç–µ–∫—É
    for (let col = 0; col < this.cols; col++) {
      if (gridCopy[0][col] && !explodingPositions.has(`0,${col}`)) {
        stack.push({r: 0, c: col});
      }
    }
    
    // –ü—Ä–æ—Ö–æ–¥–∏–º–æ –≤—Å—ñ –∑'—î–¥–Ω–∞–Ω—ñ –∫—É–ª—å–∫–∏
    while (stack.length > 0) {
      const {r, c} = stack.pop();
      const key = `${r},${c}`;
      
      // –ü—Ä–æ–ø—É—Å–∫–∞—î–º–æ —è–∫—â–æ –≤–∂–µ –≤—ñ–¥–≤—ñ–¥–∞–ª–∏
      if (connected.has(key)) continue;
      
      // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –º–µ–∂—ñ
      if (r < 0 || r >= this.rows || c < 0 || c >= this.cols) continue;
      
      // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ —â–æ –∫–ª—ñ—Ç–∏–Ω–∫–∞ —ñ—Å–Ω—É—î —ñ –Ω–µ –≤–∏–±—É—Ö–∞—î
      if (!gridCopy[r][c] || explodingPositions.has(key)) continue;
      
      // –î–æ–¥–∞—î–º–æ –¥–æ –∑'—î–¥–Ω–∞–Ω–∏—Ö
      connected.add(key);
      console.log(`üõ°Ô∏è SAFE_FLOATING: Connected bubble at ${r},${c}`);
      
      // –î–æ–¥–∞—î–º–æ —Å—É—Å—ñ–¥—ñ–≤ –¥–æ —Å—Ç–µ–∫—É
      const isEvenRow = r % 2 === 0;
      const neighbors = [
        {r: r-1, c: isEvenRow ? c-1 : c},
        {r: r-1, c: isEvenRow ? c : c+1},
        {r: r, c: c-1},
        {r: r, c: c+1},
        {r: r+1, c: isEvenRow ? c-1 : c},
        {r: r+1, c: isEvenRow ? c : c+1}
      ];
      
      for (const {r: nr, c: nc} of neighbors) {
        if (!connected.has(`${nr},${nc}`)) {
          stack.push({r: nr, c: nc});
        }
      }
    }
    
    // –ó–Ω–∞—Ö–æ–¥–∏–º–æ –ø–ª–∞–≤–∞—é—á—ñ –∫—É–ª—å–∫–∏
    const floatingBubbles = [];
    for (let row = 0; row < this.rows; row++) {
      for (let col = 0; col < this.cols; col++) {
        const key = `${row},${col}`;
        
        if (gridCopy[row][col] && 
            !connected.has(key) && 
            !explodingPositions.has(key)) {
          
          const bubbleType = gridCopy[row][col].type;
          
          if (bubbleType && bubbleType !== 'stone') {
            console.log(`üõ°Ô∏è SAFE_FLOATING: Found floating bubble at ${row},${col} of type "${bubbleType}"`);
            
            floatingBubbles.push({
              row: row,
              col: col,
              type: bubbleType,
              progress: 0
            });
          }
        }
      }
    }
    
    console.log(`üõ°Ô∏è SAFE_FLOATING: Found ${floatingBubbles.length} floating bubbles`);
    return floatingBubbles;
  }

  // –°–¢–ê–†–ê –§–£–ù–ö–¶–Ü–Ø (–ø–µ—Ä–µ—Ä–æ–±–ª—è—î–º–æ –¥–ª—è –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è –±–µ–∑–ø–µ—á–Ω–æ–≥–æ –º–µ—Ç–æ–¥—É)
  checkFloatingBubbles() {
    console.log(`üÜï NEW VERSION: checkFloatingBubbles v2.0 - Using safe floating detection`);
    
    const floatingBubbles = this.findFloatingBubblesSafely();
    
    if (floatingBubbles.length > 0) {
      console.log(`üîç FLOATING: Found ${floatingBubbles.length} floating bubbles to animate removal`);
      
      // –ö–†–ò–¢–ò–ß–ù–û –í–ê–ñ–õ–ò–í–û: –ù–ï –≤–∏–¥–∞–ª—è—î–º–æ –∫—É–ª—ñ –∑ grid —Ç—É—Ç!
      // –¢—ñ–ª—å–∫–∏ –¥–æ–¥–∞—î–º–æ –¥–æ –∞–Ω—ñ–º–∞—Ü—ñ—ó –≤–∏–±—É—Ö—É - —Ñ—ñ–∑–∏—á–Ω–µ –≤–∏–¥–∞–ª–µ–Ω–Ω—è –±—É–¥–µ –≤ loop()
      const validFloatingBubbles = floatingBubbles.filter(bubble => {
        const currentBubble = this.getGridSafely(bubble.row, bubble.col);
        if (currentBubble && currentBubble.type === bubble.type) {
          console.log(`‚úÖ FLOATING: Valid floating bubble at ${bubble.row},${bubble.col} type="${bubble.type}" - ADDING TO ANIMATION ONLY`);
          return true;
        } else {
          const actualType = currentBubble ? currentBubble.type : 'NO_BUBBLE';
          console.warn(`‚ùå FLOATING: Invalid floating bubble at ${bubble.row},${bubble.col} - expected "${bubble.type}", found "${actualType}"`);
          return false;
        }
      });
      
      if (validFloatingBubbles.length > 0) {
        // –¢–Ü–õ–¨–ö–ò –¥–æ–¥–∞—î–º–æ –¥–æ –∞–Ω—ñ–º–∞—Ü—ñ—ó - –ù–ï –í–ò–î–ê–õ–Ø–Ñ–ú–û –ó GRID!
        // –í–∏–¥–∞–ª–µ–Ω–Ω—è –±—É–¥–µ –æ–¥–∏–Ω —Ä–∞–∑ –≤ loop() –ø—ñ—Å–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—è –∞–Ω—ñ–º–∞—Ü—ñ—ó
        this.explodingBubbles = [...this.explodingBubbles, ...validFloatingBubbles];
        this.score += validFloatingBubbles.length * 10;
        this.updateScore();
        
        console.log(`üí´ FLOATING: Added ${validFloatingBubbles.length} floating bubbles to explosion animation - NO GRID DELETION HERE`);
        this.debugGridIntegrity('after_adding_floating_to_explosion');
      }
    } else {
      console.log(`‚ÑπÔ∏è FLOATING: No floating bubbles found`);
    }
  }

  // –ù–û–í–ê –ë–ï–ó–ü–ï–ß–ù–ê –§–£–ù–ö–¶–Ü–Ø –¥–ª—è –ø–æ—à—É–∫—É –≥—Ä—É–ø –ë–ï–ó –∑–º—ñ–Ω–µ–Ω–Ω—è grid
  findGroupsSafely(row, col) {
    console.log(`üõ°Ô∏è SAFE_FIND: Starting safe group search from ${row},${col}`);
    
    // –°—Ç–≤–æ—Ä—é—î–º–æ –ü–û–í–ù–£ –ö–û–ü–Ü–Æ grid –¥–ª—è –±–µ–∑–ø–µ—á–Ω–æ—ó —Ä–æ–±–æ—Ç–∏
    const gridCopy = this.grid.map(row => 
      row.map(cell => cell ? { ...cell } : null)
    );
    
    // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ —â–æ –ø–æ—á–∞—Ç–∫–æ–≤–∞ –∫–ª—ñ—Ç–∏–Ω–∫–∞ —ñ—Å–Ω—É—î
    if (!gridCopy[row] || !gridCopy[row][col]) {
      console.warn(`SAFE_FIND: No bubble at ${row},${col}`);
      return [];
    }
    
    const targetType = gridCopy[row][col].type;
    console.log(`üõ°Ô∏è SAFE_FIND: Target type is "${targetType}"`);
    
    // –ù–µ–¥—ñ–π—Å–Ω—ñ —Ç–∏–ø–∏ –Ω–µ —Ñ–æ—Ä–º—É—é—Ç—å –≥—Ä—É–ø–∏
    if (!targetType || targetType === 'stone') {
      console.log(`SAFE_FIND: Invalid type "${targetType}"`);
      return [];
    }
    
    // –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ —Å—Ç–µ–∫ –∑–∞–º—ñ—Å—Ç—å —Ä–µ–∫—É—Ä—Å—ñ—ó –¥–ª—è –Ω–∞–¥—ñ–π–Ω–æ—Å—Ç—ñ
    const stack = [{r: row, c: col}];
    const visited = new Set();
    const group = [];
    
    while (stack.length > 0) {
      const {r, c} = stack.pop();
      const key = `${r},${c}`;
      
      // –ü—Ä–æ–ø—É—Å–∫–∞—î–º–æ —è–∫—â–æ –≤–∂–µ –≤—ñ–¥–≤—ñ–¥–∞–ª–∏
      if (visited.has(key)) continue;
      
      // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –º–µ–∂—ñ
      if (r < 0 || r >= this.rows || c < 0 || c >= this.cols) continue;
      
      // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ —â–æ –∫–ª—ñ—Ç–∏–Ω–∫–∞ —ñ—Å–Ω—É—î
      if (!gridCopy[r] || !gridCopy[r][c]) continue;
      
      const currentType = gridCopy[r][c].type;
      
      // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –≤—ñ–¥–ø–æ–≤—ñ–¥–Ω—ñ—Å—Ç—å —Ç–∏–ø—É
      if (currentType !== targetType) continue;
      
      // –î–æ–¥–∞—î–º–æ –¥–æ –≥—Ä—É–ø–∏
      visited.add(key);
      group.push({
        row: r,
        col: c,
        type: currentType,
        progress: 0
      });
      
      console.log(`üõ°Ô∏è SAFE_FIND: Added ${r},${c} type="${currentType}" to group`);
      
      // –î–æ–¥–∞—î–º–æ —Å—É—Å—ñ–¥—ñ–≤ –¥–æ —Å—Ç–µ–∫—É
      const isEvenRow = r % 2 === 0;
      const neighbors = [
        {r: r-1, c: isEvenRow ? c-1 : c},
        {r: r-1, c: isEvenRow ? c : c+1},
        {r: r, c: c-1},
        {r: r, c: c+1},
        {r: r+1, c: isEvenRow ? c-1 : c},
        {r: r+1, c: isEvenRow ? c : c+1}
      ];
      
      for (const {r: nr, c: nc} of neighbors) {
        if (!visited.has(`${nr},${nc}`)) {
          stack.push({r: nr, c: nc});
        }
      }
    }
    
    console.log(`üõ°Ô∏è SAFE_FIND: Found ${group.length} bubbles of type "${targetType}":`, 
      group.map(b => `${b.row},${b.col}`));
    
    return group;
  }

  // –°–¢–ê–†–ê –§–£–ù–ö–¶–Ü–Ø (–∑–∞–ª–∏—à–∞—î–º–æ –¥–ª—è —Å—É–º—ñ—Å–Ω–æ—Å—Ç—ñ, –∞–ª–µ –ù–ï –í–ò–ö–û–†–ò–°–¢–û–í–£–Ñ–ú–û)
  findAndRemoveGroups(row, col) {
    console.log(`‚ö†Ô∏è OLD_FIND: This function is deprecated, using safe version instead`);
    return this.findGroupsSafely(row, col);
  }

  removeFloatingBubbles() {
    // stone –ø–∞–¥–∞—î —è–∫ –∑–≤–∏—á–∞–π–Ω–∞ –∫—É–ª—å–∫–∞
    this.checkFloatingBubbles();
  }

  gameOver() {
    this.isGameOver = true;
    this.playSound('game-over');
    this.shootingBubble = null;
    if (this.difficultyInterval) clearInterval(this.difficultyInterval);
    if (this.threatRowTimer) clearInterval(this.threatRowTimer);
    
    // –ó–±–µ—Ä—ñ–≥–∞—î–º–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≤ –ª—ñ–¥–µ—Ä–±–æ—Ä–¥ –∑ —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—î—é –ø—Ä–æ —Ä–µ–∂–∏–º
    if (typeof window.saveToLeaderboard === 'function') {
      window.saveToLeaderboard(this.score, this.gameMode);
    }
    
    // –ê–Ω—ñ–º–∞—Ü—ñ—è –ø–æ—è–≤–∏ –º–µ–Ω—é game over
    this.gameOverMenu.classList.remove('hidden');
    this.gameOverMenu.style.animation = 'bounceIn 0.8s ease-out';
    this.gameOverMenu.querySelector('#final-score').textContent = this.score;
  }

  pauseGame() {
    this.isPaused = true;
    this.pauseMenu.classList.remove('hidden');
  }

  resumeGame() {
    this.isPaused = false;
    this.pauseMenu.classList.add('hidden');
    this.loop();
  }

  exitGame() {
    // –í—Å—Ç–∞–Ω–æ–≤–ª—é—î–º–æ –ø—Ä–∞–≤–∏–ª—å–Ω–∏–π —Ñ–æ–Ω –ø–µ—Ä–µ–¥ –ø–æ–≤–µ—Ä–Ω–µ–Ω–Ω—è–º –≤ –º–µ–Ω—é
    if (typeof window.setGlobalBackground === 'function') window.setGlobalBackground();
    if (typeof window.showMainMenu === 'function') window.showMainMenu();
  }

  updateScore() {
    this.scoreEl.textContent = `Score: ${this.score}`;
  }

  // –§—É–Ω–∫—Ü—ñ—è –¥–ª—è –æ–ø—É—Å–∫–∞–Ω–Ω—è –≤—Å—ñ—Ö –∫—É–ª—å–æ–∫ –Ω–∞ –æ–¥–∏–Ω —Ä—è–¥ –≤–Ω–∏–∑
  dropBubblesOneRow() {
    // –ó—Å—É–≤–∞—î–º–æ –≤—Å—ñ —Ä—è–¥–∏ –≤–Ω–∏–∑ –Ω–∞ 1, –Ω–µ —É—â—ñ–ª—å–Ω—é—é—á–∏ –∫—É–ª—å–∫–∏
    const lastRow = this.rows - 1;
    for (let row = lastRow; row > 0; row--) {
      for (let col = 0; col < this.cols; col++) {
        const bubbleFromAbove = this.getGridSafely(row - 1, col);
        if (bubbleFromAbove) {
          const movedBubble = { ...bubbleFromAbove, row: row };
          this.setGridSafely(row, col, movedBubble, 'DROP_MOVE_DOWN');
        } else {
          this.setGridSafely(row, col, null, 'DROP_CLEAR_MOVED');
        }
      }
    }
    // –û—á–∏—â–∞—î–º–æ –ø–µ—Ä—à–∏–π —Ä—è–¥
    for (let col = 0; col < this.cols; col++) {
      const topBubble = this.getGridSafely(0, col);
      if (topBubble) {
        console.log(`üìâ DROP: Clearing top row bubble at 0,${col} of type "${topBubble.type}"`);
      }
      this.setGridSafely(0, col, null, 'DROP_CLEAR_TOP');
    }
    this.bubbleGenerationCounter++;
    if (this.bubbleGenerationCounter % 5 === 0) {
      this.generateSpecialPattern();
    } else {
      for (let col = 0; col < this.cols; col++) {
        // –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ –Ω–æ–≤—É –ª–æ–≥—ñ–∫—É –¥–ª—è —É–Ω–∏–∫–Ω–µ–Ω–Ω—è –¥–æ–≤–≥–∏—Ö –ø–æ—Å–ª—ñ–¥–æ–≤–Ω–æ—Å—Ç–µ–π
        const bubbleType = this.selectBubbleTypeAvoidingSequence(0, col);
        const newBubble = {
          type: bubbleType,
          row: 0,
          col: col
        };
        this.setGridSafely(0, col, newBubble, 'DROP_CREATE_NEW');
      }
    }
    this.updateColorDistribution();
    this.rebuildActiveBubblesCache();
  }

  // –ù–æ–≤–∞ —Ñ—É–Ω–∫—Ü—ñ—è –¥–ª—è –ø–µ—Ä–µ–≤—ñ—Ä–∫–∏ –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—è –≥—Ä–∏
  checkGameOver() {
    // –í–∏–¥–∞–ª–µ–Ω–æ –ø–µ—Ä–µ–≤—ñ—Ä–∫—É –ø—Ä–æ–≥—Ä–∞—à—É –ø–æ shooterY
    return false;
  }

  // Cache management for optimized collision detection
  updateActiveBubblesCache(row, col, bubble) {
    const key = `${row},${col}`;
    if (bubble === null) {
      this.activeBubbles.delete(key);
    } else {
      const {x, y} = this.gridToPixel(row, col);
      this.activeBubbles.set(key, {x, y, type: bubble.type, row, col});
    }
  }
  
  rebuildActiveBubblesCache() {
    this.activeBubbles.clear();
    for (let row = 0; row < this.rows; row++) {
      for (let col = 0; col < this.cols; col++) {
        if (this.grid[row][col]) {
          this.updateActiveBubblesCache(row, col, this.grid[row][col]);
        }
      }
    }
  }
  
  // Optimized collision detection using spatial partitioning
  checkCollisionOptimized(bubbleX, bubbleY, prevX = null, prevY = null) {
    // –Ø–∫—â–æ prevX/prevY –Ω–µ –∑–∞–¥–∞–Ω—ñ ‚Äî –ø–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –ª–∏—à–µ –ø–æ—Ç–æ—á–Ω—É –ø–æ–∑–∏—Ü—ñ—é (—Å—Ç–∞—Ä–∏–π —Ä–µ–∂–∏–º)
    if (prevX === null || prevY === null) {
      const searchRadius = this.bubbleRadius * 2.2;
      for (const [key, activeBubble] of this.activeBubbles) {
        const dx = bubbleX - activeBubble.x;
        const dy = bubbleY - activeBubble.y;
        if (Math.abs(dx) > searchRadius || Math.abs(dy) > searchRadius) continue;
        const distanceSquared = dx * dx + dy * dy;
        const collisionDistanceSquared = (this.bubbleRadius * 2) * (this.bubbleRadius * 2);
        if (distanceSquared < collisionDistanceSquared) {
          return activeBubble;
        }
      }
      return null;
    }
    // RAYCAST: –ø–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –∫–æ–ª—ñ–∑—ñ—é –ø–æ –≤—Å—ñ–π —Ç—Ä–∞—î–∫—Ç–æ—Ä—ñ—ó –º—ñ–∂ prevX,prevY —ñ bubbleX,bubbleY
    const steps = Math.ceil(Math.max(Math.abs(bubbleX - prevX), Math.abs(bubbleY - prevY)) / (this.bubbleRadius / 2));
    for (let i = 1; i <= steps; i++) {
      const t = i / steps;
      const x = prevX + (bubbleX - prevX) * t;
      const y = prevY + (bubbleY - prevY) * t;
      const searchRadius = this.bubbleRadius * 2.2;
      for (const [key, activeBubble] of this.activeBubbles) {
        const dx = x - activeBubble.x;
        const dy = y - activeBubble.y;
        if (Math.abs(dx) > searchRadius || Math.abs(dy) > searchRadius) continue;
        const distanceSquared = dx * dx + dy * dy;
        const collisionDistanceSquared = (this.bubbleRadius * 2) * (this.bubbleRadius * 2);
        if (distanceSquared < collisionDistanceSquared) {
          return activeBubble;
        }
      }
    }
    return null;
  }

  // FPS –ª—ñ—á–∏–ª—å–Ω–∏–∫
  // –§—É–Ω–∫—Ü—ñ—è –¥–ª—è –ø–µ—Ä–µ–≤—ñ—Ä–∫–∏ –ª–æ–≥—ñ–∫–∏ —Å—É—Å—ñ–¥—ñ–≤
  debugNeighbors(row, col) {
    console.log(`üîç DEBUG: Checking neighbors for position ${row},${col}`);
    
    const isEvenRow = row % 2 === 0;
    const neighbors = [
      {r: row-1, c: isEvenRow ? col-1 : col, name: 'top-left'},
      {r: row-1, c: isEvenRow ? col : col+1, name: 'top-right'},
      {r: row, c: col-1, name: 'left'},
      {r: row, c: col+1, name: 'right'},
      {r: row+1, c: isEvenRow ? col-1 : col, name: 'bottom-left'},
      {r: row+1, c: isEvenRow ? col : col+1, name: 'bottom-right'}
    ];
    
    neighbors.forEach(({r, c, name}) => {
      if (r >= 0 && r < this.rows && c >= 0 && c < this.cols) {
        const bubble = this.grid[r][c];
        const type = bubble ? bubble.type : 'EMPTY';
        console.log(`  ${name}: ${r},${c} = ${type}`);
      } else {
        console.log(`  ${name}: ${r},${c} = OUT_OF_BOUNDS`);
      }
    });
  }

  // –§—É–Ω–∫—Ü—ñ—è –¥–ª—è –ø–µ—Ä–µ–≤—ñ—Ä–∫–∏ —Ü—ñ–ª—ñ—Å–Ω–æ—Å—Ç—ñ —Å—ñ—Ç–∫–∏
  debugGridIntegrity(context = '') {
    console.log(`üîç GRID_INTEGRITY ${context}:`);
    
    const colorCounts = {};
    let totalBubbles = 0;
    
    for (let row = 0; row < this.rows; row++) {
      for (let col = 0; col < this.cols; col++) {
        if (this.grid[row][col]) {
          const type = this.grid[row][col].type;
          colorCounts[type] = (colorCounts[type] || 0) + 1;
          totalBubbles++;
        }
      }
    }
    
    console.log(`  Total bubbles: ${totalBubbles}`);
    console.log(`  Color distribution:`, colorCounts);
    console.log(`  Exploding bubbles: ${this.explodingBubbles.length}`);
    
    // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ —á–∏ —î —à–∞—Ä–∏–∫–∏ —â–æ –≤–∏–±—É—Ö–∞—é—Ç—å –∞–ª–µ –≤—Å–µ —â–µ –≤ —Å—ñ—Ç—Ü—ñ
    const mismatchedBubbles = [];
    this.explodingBubbles.forEach(bubble => {
      if (this.grid[bubble.row] && this.grid[bubble.row][bubble.col]) {
        const gridType = this.grid[bubble.row][bubble.col].type;
        if (gridType !== bubble.type) {
          mismatchedBubbles.push({
            pos: `${bubble.row},${bubble.col}`,
            expected: bubble.type,
            actual: gridType
          });
        }
      }
    });
    
    if (mismatchedBubbles.length > 0) {
      console.error(`üö® CRITICAL: Found ${mismatchedBubbles.length} mismatched exploding bubbles:`, mismatchedBubbles);
    }
  }

  drawFPS() {
    this.ctx.save();
    this.ctx.font = '16px Arial';
    this.ctx.fillStyle = 'rgba(0,0,0,0.7)';
    this.ctx.fillText(`FPS: ${this.fps}`, 10, 22);
    this.ctx.restore();
  }
} 