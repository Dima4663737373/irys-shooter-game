<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Irys Shooter</title>
  <link rel="stylesheet" href="styles/style.css">
</head>
<body>
  <div id="app">
    <div style="color: white; text-align: center; padding: 50px;">
      <h1>Loading...</h1>
      <p>If this message persists, check the browser console for errors.</p>
    </div>
  </div>
  
  <!-- ethers.js CDN -->
  <script 
    src="https://unpkg.com/ethers@5.7.2/dist/ethers.umd.min.js"
    onload="console.log('âœ… ethers.js loaded successfully:', typeof ethers !== 'undefined' ? ethers.version : 'FAILED')"
  ></script>
  
  <!-- Load Irys Contract Integration -->
  <script src="./irys-contract-integration.js" 
    onload="console.log('âœ… IrysContractIntegration loaded:', typeof window.IrysContractIntegration !== 'undefined')"
    onerror="console.warn('âš ï¸ Failed to load irys-contract-integration.js')"></script>
  
  <!-- Load Irys Network Integration as fallback -->
  <script src="./js/simple-blockchain-integration.js" 
    onload="console.log('âœ… SimpleBlockchainIntegration loaded:', typeof window.SimpleBlockchainIntegration !== 'undefined')"
    onerror="console.warn('âš ï¸ Failed to load simple-blockchain-integration.js')"></script>
  
  <!-- Minimal inline fallback for Netlify -->
  <script>
    // Only create fallback if no other integrations loaded
    setTimeout(() => {
      if (typeof window.IrysContractIntegration === 'undefined' && 
          typeof window.SimpleBlockchainIntegration === 'undefined') {
        console.log('ðŸ”„ Creating minimal fallback for Netlify...');
        
        window.SimpleBlockchainIntegration = {
          provider: null,
          
          async initialize(provider) {
            console.log('ðŸ”„ Minimal fallback: Initializing...');
            
            try {
              if (typeof ethers !== 'undefined' && provider) {
                const ethersProvider = new ethers.providers.Web3Provider(provider);
                const network = await ethersProvider.getNetwork();
                console.log(`ðŸŒ Connected to network: ${network.name} (${network.chainId})`);
                
                // Store provider for later use
                this.provider = provider;
                return true;
              } else {
                console.warn('âš ï¸ No ethers or provider, using mock mode');
                return true;
              }
            } catch (error) {
              console.warn('âš ï¸ Initialization failed, using mock mode:', error.message);
              return true; // Always succeed for fallback
            }
          },
          
          async startGameSession(gameMode, walletAddress) {
            console.log(`ðŸš€ Minimal fallback: Starting ${gameMode} game session`);
            
            try {
              // Try to create a real transaction if ethers is available
              if (typeof ethers !== 'undefined' && this.provider) {
                console.log('ðŸ”„ Attempting real transaction with fallback...');
                
                const provider = new ethers.providers.Web3Provider(this.provider);
                const signer = provider.getSigner();
                
                // Simple contract call or transaction
                const tx = await signer.sendTransaction({
                  to: walletAddress, // Send to self as test
                  value: ethers.utils.parseEther("0"), // 0 ETH
                  data: "0x" // Empty data
                });
                
                console.log('ðŸ”„ Transaction sent, waiting for confirmation...');
                const receipt = await tx.wait();
                
                console.log('âœ… Real transaction confirmed!');
                
                return {
                  success: true,
                  smartContractTxHash: receipt.transactionHash,
                  irysTransactionId: 'real_tx_' + Date.now(),
                  sessionId: 'session_' + Date.now(),
                  gameData: {
                    gameMode,
                    playerAddress: walletAddress,
                    timestamp: Date.now(),
                    action: "startGame",
                    version: "real_fallback"
                  }
                };
              } else {
                throw new Error('No ethers or ethereum provider');
              }
            } catch (error) {
              console.warn('âš ï¸ Real transaction failed, using mock:', error.message);
              
              // Fallback to mock transaction
              await new Promise(resolve => setTimeout(resolve, 2000)); // Simulate delay
              
              return {
                success: true,
                smartContractTxHash: '0x' + Math.random().toString(16).substr(2, 64),
                irysTransactionId: 'mock_fallback_' + Date.now(),
                sessionId: 'session_' + Date.now(),
                gameData: {
                  gameMode,
                  playerAddress: walletAddress,
                  timestamp: Date.now(),
                  action: "startGame",
                  version: "mock_fallback"
                }
              };
            }
          },
          
          async endGameSession(sessionId, score, walletAddress) {
            console.log(`ðŸ Minimal fallback: Ending game session ${sessionId} with score ${score}`);
            
            return {
              success: true,
              smartContractTxHash: '0x' + Math.random().toString(16).substr(2, 64),
              irysTransactionId: 'netlify_end_' + Date.now(),
              sessionId: sessionId
            };
          },
          
          async setPlayerName(playerName, walletAddress) {
            console.log(`ðŸ‘¤ Minimal fallback: Setting player name to "${playerName}"`);
            
            try {
              // Try to create a real transaction for name setting
              if (typeof ethers !== 'undefined' && this.provider) {
                console.log('ðŸ”„ Attempting real name transaction with fallback...');
                
                const provider = new ethers.providers.Web3Provider(this.provider);
                const signer = provider.getSigner();
                
                // Simple transaction with name data
                const tx = await signer.sendTransaction({
                  to: walletAddress, // Send to self
                  value: ethers.utils.parseEther("0.00000001"), // Small fee
                  data: ethers.utils.hexlify(ethers.utils.toUtf8Bytes(`setPlayerName:${playerName}`))
                });
                
                console.log('ðŸ”„ Name transaction sent, waiting for confirmation...');
                const receipt = await tx.wait();
                
                console.log('âœ… Real name transaction confirmed!');
                
                // Store name locally as well
                localStorage.setItem('playerName', playerName);
                
                return {
                  success: true,
                  smartContractTxHash: receipt.transactionHash,
                  irysTransactionId: 'real_name_' + Date.now(),
                  playerName: playerName
                };
              } else {
                throw new Error('No ethers or ethereum provider');
              }
            } catch (error) {
              console.warn('âš ï¸ Real name transaction failed, using mock:', error.message);
              
              // Fallback to mock transaction
              await new Promise(resolve => setTimeout(resolve, 1500)); // Simulate delay
              
              // Store name locally
              localStorage.setItem('playerName', playerName);
              
              return {
                success: true,
                smartContractTxHash: '0x' + Math.random().toString(16).substr(2, 64),
                irysTransactionId: 'mock_name_' + Date.now(),
                playerName: playerName
              };
            }
          }
        };
        
        console.log('âœ… Minimal fallback integration created for Netlify');
      }
    }, 2000); // Wait 2 seconds for other scripts to load
  </script>
  
  <!-- Load main application -->
  <script type="module" src="main-new.js"></script>
</body>
</html>