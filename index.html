<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Irys Shooter</title>
  <link rel="stylesheet" href="styles/style.css">
</head>
<body>
  <div id="app">
    <div style="color: white; text-align: center; padding: 50px;">
      <h1>Loading...</h1>
      <p>If this message persists, check the browser console for errors.</p>
    </div>
  </div>
  
  <!-- ethers.js CDN -->
  <script 
    src="https://unpkg.com/ethers@5.7.2/dist/ethers.umd.min.js"
    onload="console.log('‚úÖ ethers.js loaded successfully:', typeof ethers !== 'undefined' ? ethers.version : 'FAILED')"
  ></script>
  
  <!-- Load Irys Contract Integration -->
  <script src="./irys-contract-integration.js" 
    onload="console.log('‚úÖ IrysContractIntegration loaded:', typeof window.IrysContractIntegration !== 'undefined')"
    onerror="console.warn('‚ö†Ô∏è Failed to load irys-contract-integration.js')"></script>
  
  <!-- Load Irys Network Integration as fallback -->
  <script src="./js/simple-blockchain-integration.js" 
    onload="console.log('‚úÖ SimpleBlockchainIntegration loaded:', typeof window.SimpleBlockchainIntegration !== 'undefined')"
    onerror="console.warn('‚ö†Ô∏è Failed to load simple-blockchain-integration.js')"></script>
  
  <!-- Minimal inline fallback for Netlify -->
  <script>
    // Only create fallback if no other integrations loaded
    setTimeout(() => {
      if (typeof window.IrysContractIntegration === 'undefined' && 
          typeof window.SimpleBlockchainIntegration === 'undefined') {
        console.log('üîÑ Creating minimal fallback for Netlify...');
        
        window.SimpleBlockchainIntegration = {
          provider: null,
          
          async initialize(provider) {
            console.log('üîÑ Minimal fallback: Initializing...');
            
            try {
              if (typeof ethers !== 'undefined' && provider) {
                const ethersProvider = new ethers.providers.Web3Provider(provider);
                const network = await ethersProvider.getNetwork();
                console.log(`üåê Connected to network: ${network.name} (${network.chainId})`);
                
                // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ —á–∏ —Ü–µ Irys Testnet
                if (network.chainId !== 1270) {
                  console.log('üîÑ Attempting to switch to Irys Testnet...');
                  try {
                    // –°–ø—Ä–æ–±—É—î–º–æ –ø–µ—Ä–µ–∫–ª—é—á–∏—Ç–∏—Å—è –Ω–∞ Irys Testnet
                    await provider.request({
                      method: 'wallet_switchEthereumChain',
                      params: [{ chainId: '0x4F6' }], // 1270 –≤ hex
                    });
                  } catch (switchError) {
                    if (switchError.code === 4902) {
                      // –ú–µ—Ä–µ–∂–∞ –Ω–µ –¥–æ–¥–∞–Ω–∞, –¥–æ–¥–∞—î–º–æ —ó—ó
                      await provider.request({
                        method: 'wallet_addEthereumChain',
                        params: [{
                          chainId: '0x4F6',
                          chainName: 'Irys Testnet',
                          nativeCurrency: {
                            name: 'IRYS',
                            symbol: 'IRYS',
                            decimals: 18
                          },
                          rpcUrls: ['https://testnet-rpc.irys.xyz/v1/execution-rpc'],
                          blockExplorerUrls: ['https://testnet-explorer.irys.xyz/']
                        }]
                      });
                    }
                  }
                }
                
                this.provider = provider;
                return true;
              } else {
                console.warn('‚ö†Ô∏è No ethers or provider, using mock mode');
                return true;
              }
            } catch (error) {
              console.warn('‚ö†Ô∏è Initialization failed, using mock mode:', error.message);
              return true;
            }
          },
          
          async setPlayerName(playerName, walletAddress) {
            console.log(`üë§ Minimal fallback: Setting player name to "${playerName}"`);
            
            try {
              // –°–ø—Ä–æ–±—É—î–º–æ —Ä–µ–∞–ª—å–Ω—É —Ç—Ä–∞–Ω–∑–∞–∫—Ü—ñ—é —á–µ—Ä–µ–∑ –≥–∞–º–∞–Ω–µ—Ü—å
              if (typeof ethers !== 'undefined' && this.provider) {
                console.log('üîÑ Attempting real blockchain transaction...');
                
                const provider = new ethers.providers.Web3Provider(this.provider);
                const signer = provider.getSigner();
                const userAddress = await signer.getAddress();
                
                // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –º–µ—Ä–µ–∂—É —ñ –ø–µ—Ä–µ–∫–ª—é—á–∞—î–º–æ—Å—è –Ω–∞ Irys Testnet —è–∫—â–æ –ø–æ—Ç—Ä—ñ–±–Ω–æ
                const network = await provider.getNetwork();
                if (network.chainId !== 1270) {
                  console.log('üîÑ Switching to Irys Testnet...');
                  await this.switchToIrysNetwork();
                }
                
                // –í–∏–∫–æ–Ω—É—î–º–æ —Ä–µ–∞–ª—å–Ω—É —Ç—Ä–∞–Ω–∑–∞–∫—Ü—ñ—é –∑ –ø—ñ–¥–ø–∏—Å–æ–º —á–µ—Ä–µ–∑ –≥–∞–º–∞–Ω–µ—Ü—å
                const tx = await signer.sendTransaction({
                  to: userAddress, // –í—ñ–¥–ø—Ä–∞–≤–ª—è—î–º–æ —Å–æ–±—ñ
                  value: ethers.utils.parseEther('0.00000001'), // –ú—ñ–Ω—ñ–º–∞–ª—å–Ω–∞ —Å—É–º–∞
                  data: ethers.utils.hexlify(ethers.utils.toUtf8Bytes(`setPlayerName:${playerName}`)),
                  gasLimit: 100000
                });
                
                console.log('‚è≥ Waiting for transaction confirmation...');
                const receipt = await tx.wait();
                console.log('‚úÖ Transaction confirmed:', receipt.transactionHash);
                
                // –ó–±–µ—Ä—ñ–≥–∞—î–º–æ –ª–æ–∫–∞–ª—å–Ω–æ –ø—ñ—Å–ª—è —É—Å–ø—ñ—à–Ω–æ—ó —Ç—Ä–∞–Ω–∑–∞–∫—Ü—ñ—ó
                localStorage.setItem('playerName', playerName);
                
                return {
                  success: true,
                  smartContractTxHash: receipt.transactionHash,
                  irysTransactionId: 'irys_' + Date.now(),
                  playerName: playerName
                };
              } else {
                throw new Error('No ethers or ethereum provider available');
              }
            } catch (error) {
              console.warn('‚ö†Ô∏è Blockchain transaction failed:', error.message);
              
              // Fallback –¥–æ –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ –∑–±–µ—Ä–µ–∂–µ–Ω–Ω—è —Ç—ñ–ª—å–∫–∏ —è–∫—â–æ —Ç—Ä–∞–Ω–∑–∞–∫—Ü—ñ—è –Ω–µ –≤–¥–∞–ª–∞—Å—è
              localStorage.setItem('playerName', playerName);
              
              return {
                success: true,
                smartContractTxHash: '0xfallback' + Date.now(),
                irysTransactionId: 'fallback_' + Date.now(),
                playerName: playerName,
                note: 'Saved locally due to blockchain error'
              };
            }
          },
          
          async startGameSession(gameMode, walletAddress) {
            console.log(`üöÄ Minimal fallback: Starting ${gameMode} game session`);
            
            try {
              // –ó–∞–≤–∂–¥–∏ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ mock –¥–ª—è —Å—Ç–∞–±—ñ–ª—å–Ω–æ—Å—Ç—ñ
              console.log('üîÑ Using mock transaction for game session...');
              await new Promise(resolve => setTimeout(resolve, 2000));
              
              return {
                success: true,
                smartContractTxHash: '0x' + Math.random().toString(16).substr(2, 64),
                irysTransactionId: 'mock_session_' + Date.now(),
                sessionId: 'session_' + Date.now(),
                gameData: {
                  gameMode,
                  playerAddress: walletAddress,
                  timestamp: Date.now(),
                  action: "startGame",
                  version: "mock_fallback"
                }
              };
            } catch (error) {
              console.error('‚ùå Game session failed:', error);
              return {
                success: false,
                error: error.message
              };
            }
          },
          
          async endGameSession(sessionId, score, walletAddress) {
            console.log(`üèÅ Minimal fallback: Ending game session ${sessionId} with score ${score}`);
            
            return {
              success: true,
              smartContractTxHash: '0x' + Math.random().toString(16).substr(2, 64),
              irysTransactionId: 'mock_end_' + Date.now(),
              sessionId: sessionId
            };
          }
        };
        
        console.log('‚úÖ Minimal fallback integration created for Netlify');
      }
    }, 2000); // Wait 2 seconds for other scripts to load
  </script>
  
  <!-- Load main application -->
  <script type="module" src="main-new.js"></script>
</body>
<!-- –î–æ–¥–∞—Ç–∏ –ø–µ—Ä–µ–¥ –∑–∞–∫—Ä–∏–≤–∞—é—á–∏–º —Ç–µ–≥–æ–º </body> -->
<script src="https://cdn.jsdelivr.net/npm/web3@1.8.0/dist/web3.min.js"></script>
<script src="js/leaderboard-integration.js"></script>
</html>